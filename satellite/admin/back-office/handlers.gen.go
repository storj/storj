// AUTOGENERATED BY private/apigen
// DO NOT EDIT.

package admin

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/spacemonkeygo/monkit/v3"
	"github.com/zeebo/errs"
	"go.uber.org/zap"

	"storj.io/common/uuid"
	"storj.io/storj/private/api"
	"storj.io/storj/satellite/admin/back-office/changehistory"
	"storj.io/storj/satellite/console"
)

const dateLayout = "2006-01-02T15:04:05.999Z"

var ErrSettingsAPI = errs.Class("admin settings api")
var ErrPlacementsAPI = errs.Class("admin placements api")
var ErrProductsAPI = errs.Class("admin products api")
var ErrUsersAPI = errs.Class("admin users api")
var ErrProjectsAPI = errs.Class("admin projects api")
var ErrSearchAPI = errs.Class("admin search api")
var ErrChangehistoryAPI = errs.Class("admin changehistory api")

type SettingsService interface {
	GetSettings(ctx context.Context, authInfo *AuthInfo) (*Settings, api.HTTPError)
}

type PlacementManagementService interface {
	GetPlacements(ctx context.Context) ([]PlacementInfo, api.HTTPError)
}

type ProductManagementService interface {
	GetProducts(ctx context.Context) ([]ProductInfo, api.HTTPError)
}

type UserManagementService interface {
	GetFreezeEventTypes(ctx context.Context) ([]FreezeEventType, api.HTTPError)
	GetUserKinds(ctx context.Context) ([]console.KindInfo, api.HTTPError)
	GetUserStatuses(ctx context.Context) ([]console.UserStatusInfo, api.HTTPError)
	SearchUsers(ctx context.Context, term string) ([]AccountMin, api.HTTPError)
	GetUserByEmail(ctx context.Context, email string) (*UserAccount, api.HTTPError)
	GetUser(ctx context.Context, userID uuid.UUID) (*UserAccount, api.HTTPError)
	UpdateUser(ctx context.Context, authInfo *AuthInfo, userID uuid.UUID, request UpdateUserRequest) (*UserAccount, api.HTTPError)
	DisableUser(ctx context.Context, authInfo *AuthInfo, userID uuid.UUID, request DisableUserRequest) (*UserAccount, api.HTTPError)
	ToggleFreezeUser(ctx context.Context, authInfo *AuthInfo, userID uuid.UUID, request ToggleFreezeUserRequest) api.HTTPError
	ToggleMFA(ctx context.Context, authInfo *AuthInfo, userID uuid.UUID, request ToggleMfaRequest) api.HTTPError
	CreateRestKey(ctx context.Context, authInfo *AuthInfo, userID uuid.UUID, request CreateRestKeyRequest) (*string, api.HTTPError)
}

type ProjectManagementService interface {
	GetProjectStatuses(ctx context.Context) ([]ProjectStatusInfo, api.HTTPError)
	GetProject(ctx context.Context, publicID uuid.UUID) (*Project, api.HTTPError)
	GetProjectBuckets(ctx context.Context, publicID uuid.UUID, search, page, limit string, since, before time.Time) (*BucketInfoPage, api.HTTPError)
	UpdateBucket(ctx context.Context, authInfo *AuthInfo, publicID uuid.UUID, bucketName string, request UpdateBucketRequest) api.HTTPError
	GetBucketState(ctx context.Context, publicID uuid.UUID, bucketName string) (*BucketState, api.HTTPError)
	UpdateProject(ctx context.Context, authInfo *AuthInfo, publicID uuid.UUID, request UpdateProjectRequest) (*Project, api.HTTPError)
	DisableProject(ctx context.Context, authInfo *AuthInfo, publicID uuid.UUID, request DisableProjectRequest) api.HTTPError
	UpdateProjectLimits(ctx context.Context, authInfo *AuthInfo, publicID uuid.UUID, request ProjectLimitsUpdateRequest) (*Project, api.HTTPError)
	UpdateProjectEntitlements(ctx context.Context, authInfo *AuthInfo, publicID uuid.UUID, request UpdateProjectEntitlementsRequest) (*ProjectEntitlements, api.HTTPError)
}

type SearchService interface {
	SearchUsersOrProjects(ctx context.Context, authInfo *AuthInfo, term string) (*SearchResult, api.HTTPError)
}

type ChangeHistoryService interface {
	GetChangeHistory(ctx context.Context, exact, itemType, id string) ([]changehistory.ChangeLog, api.HTTPError)
}

// SettingsHandler is an api handler that implements all Settings API endpoints functionality.
type SettingsHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service SettingsService
	auth    *Authorizer
}

// PlacementManagementHandler is an api handler that implements all PlacementManagement API endpoints functionality.
type PlacementManagementHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service PlacementManagementService
}

// ProductManagementHandler is an api handler that implements all ProductManagement API endpoints functionality.
type ProductManagementHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service ProductManagementService
}

// UserManagementHandler is an api handler that implements all UserManagement API endpoints functionality.
type UserManagementHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service UserManagementService
	auth    *Authorizer
}

// ProjectManagementHandler is an api handler that implements all ProjectManagement API endpoints functionality.
type ProjectManagementHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service ProjectManagementService
	auth    *Authorizer
}

// SearchHandler is an api handler that implements all Search API endpoints functionality.
type SearchHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service SearchService
	auth    *Authorizer
}

// ChangeHistoryHandler is an api handler that implements all ChangeHistory API endpoints functionality.
type ChangeHistoryHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service ChangeHistoryService
	auth    *Authorizer
}

func NewSettings(log *zap.Logger, mon *monkit.Scope, service SettingsService, router *mux.Router, auth *Authorizer) *SettingsHandler {
	handler := &SettingsHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	settingsRouter := router.PathPrefix("/back-office/api/v1/settings").Subrouter()
	settingsRouter.HandleFunc("/", handler.handleGetSettings).Methods("GET")

	return handler
}

func NewPlacementManagement(log *zap.Logger, mon *monkit.Scope, service PlacementManagementService, router *mux.Router) *PlacementManagementHandler {
	handler := &PlacementManagementHandler{
		log:     log,
		mon:     mon,
		service: service,
	}

	placementsRouter := router.PathPrefix("/back-office/api/v1/placements").Subrouter()
	placementsRouter.HandleFunc("/", handler.handleGetPlacements).Methods("GET")

	return handler
}

func NewProductManagement(log *zap.Logger, mon *monkit.Scope, service ProductManagementService, router *mux.Router) *ProductManagementHandler {
	handler := &ProductManagementHandler{
		log:     log,
		mon:     mon,
		service: service,
	}

	productsRouter := router.PathPrefix("/back-office/api/v1/products").Subrouter()
	productsRouter.HandleFunc("/", handler.handleGetProducts).Methods("GET")

	return handler
}

func NewUserManagement(log *zap.Logger, mon *monkit.Scope, service UserManagementService, router *mux.Router, auth *Authorizer) *UserManagementHandler {
	handler := &UserManagementHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	usersRouter := router.PathPrefix("/back-office/api/v1/users").Subrouter()
	usersRouter.HandleFunc("/freeze-event-types", handler.handleGetFreezeEventTypes).Methods("GET")
	usersRouter.HandleFunc("/kinds", handler.handleGetUserKinds).Methods("GET")
	usersRouter.HandleFunc("/statuses", handler.handleGetUserStatuses).Methods("GET")
	usersRouter.HandleFunc("/", handler.handleSearchUsers).Methods("GET")
	usersRouter.HandleFunc("/email/{email}", handler.handleGetUserByEmail).Methods("GET")
	usersRouter.HandleFunc("/{userID}", handler.handleGetUser).Methods("GET")
	usersRouter.HandleFunc("/{userID}", handler.handleUpdateUser).Methods("PATCH")
	usersRouter.HandleFunc("/{userID}", handler.handleDisableUser).Methods("PUT")
	usersRouter.HandleFunc("/{userID}/freeze-events", handler.handleToggleFreezeUser).Methods("PUT")
	usersRouter.HandleFunc("/{userID}/mfa", handler.handleToggleMFA).Methods("PUT")
	usersRouter.HandleFunc("/rest-keys/{userID}", handler.handleCreateRestKey).Methods("POST")

	return handler
}

func NewProjectManagement(log *zap.Logger, mon *monkit.Scope, service ProjectManagementService, router *mux.Router, auth *Authorizer) *ProjectManagementHandler {
	handler := &ProjectManagementHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	projectsRouter := router.PathPrefix("/back-office/api/v1/projects").Subrouter()
	projectsRouter.HandleFunc("/statuses", handler.handleGetProjectStatuses).Methods("GET")
	projectsRouter.HandleFunc("/{publicID}", handler.handleGetProject).Methods("GET")
	projectsRouter.HandleFunc("/{publicID}/buckets", handler.handleGetProjectBuckets).Methods("GET")
	projectsRouter.HandleFunc("/{publicID}/buckets/{bucketName}", handler.handleUpdateBucket).Methods("PATCH")
	projectsRouter.HandleFunc("/{publicID}/buckets/{bucketName}/state", handler.handleGetBucketState).Methods("GET")
	projectsRouter.HandleFunc("/{publicID}", handler.handleUpdateProject).Methods("PATCH")
	projectsRouter.HandleFunc("/{publicID}", handler.handleDisableProject).Methods("PUT")
	projectsRouter.HandleFunc("/{publicID}/limits", handler.handleUpdateProjectLimits).Methods("PATCH")
	projectsRouter.HandleFunc("/{publicID}/entitlements", handler.handleUpdateProjectEntitlements).Methods("PATCH")

	return handler
}

func NewSearch(log *zap.Logger, mon *monkit.Scope, service SearchService, router *mux.Router, auth *Authorizer) *SearchHandler {
	handler := &SearchHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	searchRouter := router.PathPrefix("/back-office/api/v1/search").Subrouter()
	searchRouter.HandleFunc("/", handler.handleSearchUsersOrProjects).Methods("GET")

	return handler
}

func NewChangeHistory(log *zap.Logger, mon *monkit.Scope, service ChangeHistoryService, router *mux.Router, auth *Authorizer) *ChangeHistoryHandler {
	handler := &ChangeHistoryHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	changehistoryRouter := router.PathPrefix("/back-office/api/v1/changehistory").Subrouter()
	changehistoryRouter.HandleFunc("/", handler.handleGetChangeHistory).Methods("GET")

	return handler
}

func (h *SettingsHandler) handleGetSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	retVal, httpErr := h.service.GetSettings(ctx, authInfo)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetSettings response", zap.Error(ErrSettingsAPI.Wrap(err)))
	}
}

func (h *PlacementManagementHandler) handleGetPlacements(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	retVal, httpErr := h.service.GetPlacements(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetPlacements response", zap.Error(ErrPlacementsAPI.Wrap(err)))
	}
}

func (h *ProductManagementHandler) handleGetProducts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	retVal, httpErr := h.service.GetProducts(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetProducts response", zap.Error(ErrProductsAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGetFreezeEventTypes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	retVal, httpErr := h.service.GetFreezeEventTypes(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetFreezeEventTypes response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGetUserKinds(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 1) {
		return
	}

	retVal, httpErr := h.service.GetUserKinds(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetUserKinds response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGetUserStatuses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 1) {
		return
	}

	retVal, httpErr := h.service.GetUserStatuses(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetUserStatuses response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleSearchUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	term := r.URL.Query().Get("term")
	if term == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'term' can't be empty"))
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 1) {
		return
	}

	retVal, httpErr := h.service.SearchUsers(ctx, term)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json SearchUsers response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGetUserByEmail(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	email, ok := mux.Vars(r)["email"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing email route param"))
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 1) {
		return
	}

	retVal, httpErr := h.service.GetUserByEmail(ctx, email)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetUserByEmail response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 1) {
		return
	}

	retVal, httpErr := h.service.GetUser(ctx, userID)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetUser response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleUpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := UpdateUserRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	retVal, httpErr := h.service.UpdateUser(ctx, authInfo, userID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json UpdateUser response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleDisableUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := DisableUserRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	retVal, httpErr := h.service.DisableUser(ctx, authInfo, userID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json DisableUser response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleToggleFreezeUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := ToggleFreezeUserRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	httpErr := h.service.ToggleFreezeUser(ctx, authInfo, userID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *UserManagementHandler) handleToggleMFA(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := ToggleMfaRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	if h.auth.IsRejected(w, r, 32) {
		return
	}

	httpErr := h.service.ToggleMFA(ctx, authInfo, userID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *UserManagementHandler) handleCreateRestKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	userIDParam, ok := mux.Vars(r)["userID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing userID route param"))
		return
	}

	userID, err := uuid.FromString(userIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := CreateRestKeyRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	if h.auth.IsRejected(w, r, 65536) {
		return
	}

	retVal, httpErr := h.service.CreateRestKey(ctx, authInfo, userID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json CreateRestKey response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGetProjectStatuses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 262144) {
		return
	}

	retVal, httpErr := h.service.GetProjectStatuses(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetProjectStatuses response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGetProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 262144) {
		return
	}

	retVal, httpErr := h.service.GetProject(ctx, publicID)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetProject response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGetProjectBuckets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	search := r.URL.Query().Get("search")
	if search == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'search' can't be empty"))
		return
	}

	page := r.URL.Query().Get("page")
	if page == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'page' can't be empty"))
		return
	}

	limit := r.URL.Query().Get("limit")
	if limit == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'limit' can't be empty"))
		return
	}

	sinceParam := r.URL.Query().Get("since")
	if sinceParam == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'since' can't be empty"))
		return
	}

	since, err := time.Parse(dateLayout, sinceParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	beforeParam := r.URL.Query().Get("before")
	if beforeParam == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'before' can't be empty"))
		return
	}

	before, err := time.Parse(dateLayout, beforeParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 262144, 268435456) {
		return
	}

	retVal, httpErr := h.service.GetProjectBuckets(ctx, publicID, search, page, limit, since, before)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetProjectBuckets response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleUpdateBucket(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	bucketName, ok := mux.Vars(r)["bucketName"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing bucketName route param"))
		return
	}

	payload := UpdateBucketRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	httpErr := h.service.UpdateBucket(ctx, authInfo, publicID, bucketName, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *ProjectManagementHandler) handleGetBucketState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	bucketName, ok := mux.Vars(r)["bucketName"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing bucketName route param"))
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 262144, 268435456) {
		return
	}

	retVal, httpErr := h.service.GetBucketState(ctx, publicID, bucketName)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetBucketState response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleUpdateProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := UpdateProjectRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	retVal, httpErr := h.service.UpdateProject(ctx, authInfo, publicID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json UpdateProject response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleDisableProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := DisableProjectRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	httpErr := h.service.DisableProject(ctx, authInfo, publicID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *ProjectManagementHandler) handleUpdateProjectLimits(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := ProjectLimitsUpdateRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	if h.auth.IsRejected(w, r, 524288) {
		return
	}

	retVal, httpErr := h.service.UpdateProjectLimits(ctx, authInfo, publicID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json UpdateProjectLimits response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleUpdateProjectEntitlements(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	publicIDParam, ok := mux.Vars(r)["publicID"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing publicID route param"))
		return
	}

	publicID, err := uuid.FromString(publicIDParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	payload := UpdateProjectEntitlementsRequest{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	if h.auth.IsRejected(w, r, 4194304) {
		return
	}

	retVal, httpErr := h.service.UpdateProjectEntitlements(ctx, authInfo, publicID, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json UpdateProjectEntitlements response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *SearchHandler) handleSearchUsersOrProjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	term := r.URL.Query().Get("term")
	if term == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'term' can't be empty"))
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	authInfo := h.auth.GetAuthInfo(r)
	if authInfo == nil || len(authInfo.Groups) == 0 || authInfo.Email == "" {
		api.ServeError(h.log, w, http.StatusUnauthorized, errs.New("Unauthorized"))
		return
	}

	retVal, httpErr := h.service.SearchUsersOrProjects(ctx, authInfo, term)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json SearchUsersOrProjects response", zap.Error(ErrSearchAPI.Wrap(err)))
	}
}

func (h *ChangeHistoryHandler) handleGetChangeHistory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	exact := r.URL.Query().Get("exact")
	if exact == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'exact' can't be empty"))
		return
	}

	itemType := r.URL.Query().Get("itemType")
	if itemType == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'itemType' can't be empty"))
		return
	}

	id := r.URL.Query().Get("id")
	if id == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'id' can't be empty"))
		return
	}

	if err = h.auth.VerifyHost(r); err != nil {
		api.ServeError(h.log, w, http.StatusForbidden, err)
		return
	}

	if h.auth.IsRejected(w, r, 4294967296) {
		return
	}

	retVal, httpErr := h.service.GetChangeHistory(ctx, exact, itemType, id)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetChangeHistory response", zap.Error(ErrChangehistoryAPI.Wrap(err)))
	}
}
