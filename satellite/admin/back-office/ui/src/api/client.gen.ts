// AUTOGENERATED BY private/apigen
// DO NOT EDIT.

import { HttpClient } from '@/utils/httpClient';
import { Time, UUID } from '@/types/common';

export class AccountFlags {
    create: boolean;
    createRestKey: boolean;
    delete: boolean;
    markPendingDeletion: boolean;
    history: boolean;
    list: boolean;
    projects: boolean;
    search: boolean;
    suspend: boolean;
    unsuspend: boolean;
    disableMFA: boolean;
    updateLimits: boolean;
    updatePlacement: boolean;
    updateStatus: boolean;
    updateEmail: boolean;
    updateKind: boolean;
    updateName: boolean;
    updateUserAgent: boolean;
    view: boolean;
}

export class AccountMin {
    id: UUID;
    fullName: string;
    email: string;
    kind: KindInfo;
    status: UserStatusInfo;
    createdAt: Time;
}

export class BucketFlags {
    create: boolean;
    delete: boolean;
    history: boolean;
    list: boolean;
    updateInfo: boolean;
    updatePlacement: boolean;
    updateValueAttribution: boolean;
    view: boolean;
}

export class BucketInfo {
    name: string;
    userAgent: string;
    placement: string;
    storage: number;
    egress: number;
    segmentCount: number;
    createdAt: Time;
}

export class BucketInfoPage {
    items: BucketInfo[] | null;
    limit: number;
    offset: number;
    pageCount: number;
    currentPage: number;
    totalCount: number;
}

export class BucketState {
    empty: boolean;
}

export class ChangeLog {
    id: UUID;
    userID: UUID;
    projectID?: UUID | null;
    bucketName?: string | null;
    adminEmail: string;
    itemType: string;
    reason: string;
    operation: string;
    changes: Record<string, unknown> | null;
    timestamp: Time;
}

export class CreateRestKeyRequest {
    expiration: Time;
    reason: string;
}

export class DisableProjectRequest {
    setPendingDeletion: boolean;
    reason: string;
}

export class DisableUserRequest {
    setPendingDeletion: boolean;
    reason: string;
}

export class FeatureFlags {
    account: AccountFlags;
    project: ProjectFlags;
    bucket: BucketFlags;
    dashboard: boolean;
    operator: boolean;
    signOut: boolean;
    switchSatellite: boolean;
}

export class FreezeEventType {
    name: string;
    value: number;
}

export class KindInfo {
    value: number;
    name: string;
    hasPaidPrivileges: boolean;
}

export class MiniProductInfo {
    productName: string;
    storageMBMonthCents: string;
    egressMBCents: string;
    segmentMonthCents: string;
    egressDiscountRatio: string;
}

export class PlacementInfo {
    id: number;
    location: string;
}

export class ProductInfo {
    productID: number;
    productName: string;
    storageMBMonthCents: string;
    egressMBCents: string;
    segmentMonthCents: string;
    egressDiscountRatio: string;
}

export class Project {
    id: UUID;
    name: string;
    description: string;
    userAgent: string;
    owner: User;
    createdAt: Time;
    defaultPlacement: number;
    rateLimit: number | null;
    burstLimit: number | null;
    rateLimitHead: number | null;
    burstLimitHead: number | null;
    rateLimitGet: number | null;
    burstLimitGet: number | null;
    rateLimitPut: number | null;
    burstLimitPut: number | null;
    rateLimitDelete: number | null;
    burstLimitDelete: number | null;
    rateLimitList: number | null;
    burstLimitList: number | null;
    maxBuckets: number | null;
    bandwidthLimit: number | null;
    userSetBandwidthLimit: number | null;
    bandwidthUsed: number;
    storageLimit: number | null;
    userSetStorageLimit: number | null;
    storageUsed: number | null;
    segmentLimit: number | null;
    segmentUsed: number | null;
    status: ProjectStatusInfo | null;
    entitlements: ProjectEntitlements | null;
}

export class ProjectEntitlements {
    newBucketPlacements: string[] | null;
    computeAccessToken: string;
    placementProductMappings: Record<string, MiniProductInfo> | null;
}

export class ProjectFlags {
    create: boolean;
    delete: boolean;
    markPendingDeletion: boolean;
    history: boolean;
    list: boolean;
    updateInfo: boolean;
    updateLimits: boolean;
    updatePlacement: boolean;
    updateValueAttribution: boolean;
    setEntitlements: boolean;
    view: boolean;
    memberList: boolean;
    memberAdd: boolean;
    memberRemove: boolean;
}

export class ProjectLimitsUpdateRequest {
    maxBuckets: number | null;
    storageLimit: number | null;
    bandwidthLimit: number | null;
    segmentLimit: number | null;
    rateLimit: number | null;
    burstLimit: number | null;
    userSetStorageLimit: number | null;
    userSetBandwidthLimit: number | null;
    rateLimitHead: number | null;
    burstLimitHead: number | null;
    rateLimitGet: number | null;
    burstLimitGet: number | null;
    rateLimitPut: number | null;
    burstLimitPut: number | null;
    rateLimitDelete: number | null;
    burstLimitDelete: number | null;
    rateLimitList: number | null;
    burstLimitList: number | null;
    reason: string;
}

export class ProjectStatusInfo {
    name: string;
    value: number;
}

export class SearchResult {
    project: Project | null;
    accounts: AccountMin[] | null;
}

export class Settings {
    admin: SettingsAdmin;
}

export class SettingsAdmin {
    features: FeatureFlags;
}

export class ToggleFreezeUserRequest {
    action: string;
    type: number;
    reason: string;
}

export class ToggleMfaRequest {
    reason: string;
}

export class UpdateBucketRequest {
    userAgent: string | null;
    placement: number | null;
    reason: string;
}

export class UpdateProjectEntitlementsRequest {
    newBucketPlacements: number[] | null;
    computeAccessToken: string | null;
    placementProductMappings: Record<number, number> | null;
    reason: string;
}

export class UpdateProjectRequest {
    name: string | null;
    description: string | null;
    userAgent: string | null;
    status: number | null;
    defaultPlacement: number | null;
    reason: string;
}

export class UpdateUserRequest {
    email: string | null;
    name: string | null;
    kind: number | null;
    status: number | null;
    trialExpiration: string | null;
    userAgent: string | null;
    projectLimit: number | null;
    storageLimit: number | null;
    bandwidthLimit: number | null;
    segmentLimit: number | null;
    reason: string;
}

export class User {
    id: UUID;
    fullName: string;
    email: string;
}

export class UserAccount {
    id: UUID;
    fullName: string;
    email: string;
    kind: KindInfo;
    createdAt: Time;
    upgradeTime: Time | null;
    status: UserStatusInfo;
    userAgent: string;
    defaultPlacement: number;
    projects: UserProject[] | null;
    projectLimit: number;
    storageLimit: number;
    bandwidthLimit: number;
    segmentLimit: number;
    freezeStatus: FreezeEventType | null;
    trialExpiration: Time | null;
    mfaEnabled: boolean;
}

export class UserProject {
    id: UUID;
    name: string;
    active: boolean;
    bandwidthLimit: number;
    userSetBandwidthLimit: number | null;
    bandwidthUsed: number;
    storageLimit: number;
    userSetStorageLimit: number | null;
    storageUsed: number | null;
    segmentLimit: number;
    segmentUsed: number | null;
}

export class UserStatusInfo {
    name: string;
    value: number;
}

export class APIError extends Error {
    constructor(
        public readonly msg: string,
        public readonly responseStatusCode?: number,
    ) {
        super(msg);
    }
}

export class SettingsHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/settings';

    public async get(): Promise<Settings> {
        const fullPath = `${this.ROOT_PATH}/`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as Settings);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class PlacementManagementHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/placements';

    public async getPlacements(): Promise<PlacementInfo[]> {
        const fullPath = `${this.ROOT_PATH}/`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as PlacementInfo[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class ProductManagementHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/products';

    public async getProducts(): Promise<ProductInfo[]> {
        const fullPath = `${this.ROOT_PATH}/`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as ProductInfo[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class UserManagementHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/users';

    public async getFreezeEventTypes(): Promise<FreezeEventType[]> {
        const fullPath = `${this.ROOT_PATH}/freeze-event-types`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as FreezeEventType[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getUserKinds(): Promise<KindInfo[]> {
        const fullPath = `${this.ROOT_PATH}/kinds`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as KindInfo[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getUserStatuses(): Promise<UserStatusInfo[]> {
        const fullPath = `${this.ROOT_PATH}/statuses`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as UserStatusInfo[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async searchUsers(term: string): Promise<AccountMin[]> {
        const u = new URL(`${this.ROOT_PATH}/`, window.location.href);
        u.searchParams.set('term', term);
        const fullPath = u.toString();
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as AccountMin[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getUserByEmail(email: string): Promise<UserAccount> {
        const fullPath = `${this.ROOT_PATH}/email/${email}`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as UserAccount);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getUser(userID: UUID): Promise<UserAccount> {
        const fullPath = `${this.ROOT_PATH}/${userID}`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as UserAccount);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async updateUser(request: UpdateUserRequest, userID: UUID): Promise<UserAccount> {
        const fullPath = `${this.ROOT_PATH}/${userID}`;
        const response = await this.http.patch(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as UserAccount);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async disableUser(request: DisableUserRequest, userID: UUID): Promise<UserAccount> {
        const fullPath = `${this.ROOT_PATH}/${userID}`;
        const response = await this.http.put(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as UserAccount);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async toggleFreezeUser(request: ToggleFreezeUserRequest, userID: UUID): Promise<void> {
        const fullPath = `${this.ROOT_PATH}/${userID}/freeze-events`;
        const response = await this.http.put(fullPath, JSON.stringify(request));
        if (response.ok) {
            return;
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async toggleMFA(request: ToggleMfaRequest, userID: UUID): Promise<void> {
        const fullPath = `${this.ROOT_PATH}/${userID}/mfa`;
        const response = await this.http.put(fullPath, JSON.stringify(request));
        if (response.ok) {
            return;
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async createRestKey(request: CreateRestKeyRequest, userID: UUID): Promise<string> {
        const fullPath = `${this.ROOT_PATH}/rest-keys/${userID}`;
        const response = await this.http.post(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as string);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class ProjectManagementHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/projects';

    public async getProjectStatuses(): Promise<ProjectStatusInfo[]> {
        const fullPath = `${this.ROOT_PATH}/statuses`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as ProjectStatusInfo[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getProject(publicID: UUID): Promise<Project> {
        const fullPath = `${this.ROOT_PATH}/${publicID}`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as Project);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getProjectBuckets(publicID: UUID, search: string, page: string, limit: string, since: Time, before: Time): Promise<BucketInfoPage> {
        const u = new URL(`${this.ROOT_PATH}/${publicID}/buckets`, window.location.href);
        u.searchParams.set('search', search);
        u.searchParams.set('page', page);
        u.searchParams.set('limit', limit);
        u.searchParams.set('since', since);
        u.searchParams.set('before', before);
        const fullPath = u.toString();
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as BucketInfoPage);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async updateBucket(request: UpdateBucketRequest, publicID: UUID, bucketName: string): Promise<void> {
        const fullPath = `${this.ROOT_PATH}/${publicID}/buckets/${bucketName}`;
        const response = await this.http.patch(fullPath, JSON.stringify(request));
        if (response.ok) {
            return;
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async getBucketState(publicID: UUID, bucketName: string): Promise<BucketState> {
        const fullPath = `${this.ROOT_PATH}/${publicID}/buckets/${bucketName}/state`;
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as BucketState);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async updateProject(request: UpdateProjectRequest, publicID: UUID): Promise<Project> {
        const fullPath = `${this.ROOT_PATH}/${publicID}`;
        const response = await this.http.patch(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as Project);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async disableProject(request: DisableProjectRequest, publicID: UUID): Promise<void> {
        const fullPath = `${this.ROOT_PATH}/${publicID}`;
        const response = await this.http.put(fullPath, JSON.stringify(request));
        if (response.ok) {
            return;
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async updateProjectLimits(request: ProjectLimitsUpdateRequest, publicID: UUID): Promise<Project> {
        const fullPath = `${this.ROOT_PATH}/${publicID}/limits`;
        const response = await this.http.patch(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as Project);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }

    public async updateProjectEntitlements(request: UpdateProjectEntitlementsRequest, publicID: UUID): Promise<ProjectEntitlements> {
        const fullPath = `${this.ROOT_PATH}/${publicID}/entitlements`;
        const response = await this.http.patch(fullPath, JSON.stringify(request));
        if (response.ok) {
            return response.json().then((body) => body as ProjectEntitlements);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class SearchHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/search';

    public async searchUsersOrProjects(term: string): Promise<SearchResult> {
        const u = new URL(`${this.ROOT_PATH}/`, window.location.href);
        u.searchParams.set('term', term);
        const fullPath = u.toString();
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as SearchResult);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}

export class ChangeHistoryHttpApiV1 {
    private readonly http: HttpClient = new HttpClient();
    private readonly ROOT_PATH: string = '/back-office/api/v1/changehistory';

    public async getChangeHistory(exact: string, itemType: string, id: string): Promise<ChangeLog[]> {
        const u = new URL(`${this.ROOT_PATH}/`, window.location.href);
        u.searchParams.set('exact', exact);
        u.searchParams.set('itemType', itemType);
        u.searchParams.set('id', id);
        const fullPath = u.toString();
        const response = await this.http.get(fullPath);
        if (response.ok) {
            return response.json().then((body) => body as ChangeLog[]);
        }
        const err = await response.json();
        throw new APIError(err.error, response.status);
    }
}
