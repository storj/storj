// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v1
// DO NOT EDIT.

package satellitedb

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/lib/pq"

	"github.com/mattn/go-sqlite3"
	"math/rand"
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...interface{})

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "postgres":
		sql_db, err = openpostgres(source)
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "postgres":
		db.dbMethods = newpostgres(db)
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type postgresImpl struct {
	db      *DB
	dialect __sqlbundle_postgres
	driver  driver
}

func (obj *postgresImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *postgresImpl) logStmt(stmt string, args ...interface{}) {
	postgresLogStmt(stmt, args...)
}

func (obj *postgresImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type postgresDB struct {
	db *DB
	*postgresImpl
}

func newpostgres(db *DB) *postgresDB {
	return &postgresDB{
		db: db,
		postgresImpl: &postgresImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *postgresDB) Schema() string {
	return `CREATE TABLE accounting_rollups (
	id bigserial NOT NULL,
	node_id bytea NOT NULL,
	start_time timestamp with time zone NOT NULL,
	put_total bigint NOT NULL,
	get_total bigint NOT NULL,
	get_audit_total bigint NOT NULL,
	get_repair_total bigint NOT NULL,
	put_repair_total bigint NOT NULL,
	at_rest_total double precision NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_timestamps (
	name text NOT NULL,
	value timestamp with time zone NOT NULL,
	PRIMARY KEY ( name )
);
CREATE TABLE bucket_bandwidth_rollups (
	bucket_name bytea NOT NULL,
	project_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	interval_seconds integer NOT NULL,
	action integer NOT NULL,
	inline bigint NOT NULL,
	allocated bigint NOT NULL,
	settled bigint NOT NULL,
	PRIMARY KEY ( bucket_name, project_id, interval_start, action )
);
CREATE TABLE bucket_storage_tallies (
	bucket_name bytea NOT NULL,
	project_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	inline bigint NOT NULL,
	remote bigint NOT NULL,
	remote_segments_count integer NOT NULL,
	inline_segments_count integer NOT NULL,
	object_count integer NOT NULL,
	metadata_size bigint NOT NULL,
	PRIMARY KEY ( bucket_name, project_id, interval_start )
);
CREATE TABLE bucket_usages (
	id bytea NOT NULL,
	bucket_id bytea NOT NULL,
	rollup_end_time timestamp with time zone NOT NULL,
	remote_stored_data bigint NOT NULL,
	inline_stored_data bigint NOT NULL,
	remote_segments integer NOT NULL,
	inline_segments integer NOT NULL,
	objects integer NOT NULL,
	metadata_size bigint NOT NULL,
	repair_egress bigint NOT NULL,
	get_egress bigint NOT NULL,
	audit_egress bigint NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE certRecords (
	publickey bytea NOT NULL,
	id bytea NOT NULL,
	update_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE injuredsegments (
	path bytea NOT NULL,
	data bytea NOT NULL,
	attempted timestamp,
	PRIMARY KEY ( path )
);
CREATE TABLE irreparabledbs (
	segmentpath bytea NOT NULL,
	segmentdetail bytea NOT NULL,
	pieces_lost_count bigint NOT NULL,
	seg_damaged_unix_sec bigint NOT NULL,
	repair_attempt_count bigint NOT NULL,
	PRIMARY KEY ( segmentpath )
);
CREATE TABLE nodes (
	id bytea NOT NULL,
	address text NOT NULL,
	last_net text NOT NULL,
	protocol integer NOT NULL,
	type integer NOT NULL,
	email text NOT NULL,
	wallet text NOT NULL,
	free_bandwidth bigint NOT NULL,
	free_disk bigint NOT NULL,
	major bigint NOT NULL,
	minor bigint NOT NULL,
	patch bigint NOT NULL,
	hash text NOT NULL,
	timestamp timestamp with time zone NOT NULL,
	release boolean NOT NULL,
	latency_90 bigint NOT NULL,
	audit_success_count bigint NOT NULL,
	total_audit_count bigint NOT NULL,
	uptime_success_count bigint NOT NULL,
	total_uptime_count bigint NOT NULL,
	created_at timestamp with time zone NOT NULL,
	updated_at timestamp with time zone NOT NULL,
	last_contact_success timestamp with time zone NOT NULL,
	last_contact_failure timestamp with time zone NOT NULL,
	contained boolean NOT NULL,
	disqualified timestamp with time zone,
	audit_reputation_alpha double precision NOT NULL,
	audit_reputation_beta double precision NOT NULL,
	uptime_reputation_alpha double precision NOT NULL,
	uptime_reputation_beta double precision NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE offers (
	id serial NOT NULL,
	name text NOT NULL,
	description text NOT NULL,
	award_credit_in_cents integer NOT NULL,
	invitee_credit_in_cents integer NOT NULL,
	award_credit_duration_days integer,
	invitee_credit_duration_days integer,
	redeemable_cap integer,
	expires_at timestamp with time zone NOT NULL,
	created_at timestamp with time zone NOT NULL,
	status integer NOT NULL,
	type integer NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE pending_audits (
	node_id bytea NOT NULL,
	piece_id bytea NOT NULL,
	stripe_index bigint NOT NULL,
	share_size bigint NOT NULL,
	expected_share_hash bytea NOT NULL,
	reverify_count bigint NOT NULL,
	path bytea NOT NULL,
	PRIMARY KEY ( node_id )
);
CREATE TABLE projects (
	id bytea NOT NULL,
	name text NOT NULL,
	description text NOT NULL,
	usage_limit bigint NOT NULL,
	partner_id bytea,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE registration_tokens (
	secret bytea NOT NULL,
	owner_id bytea,
	project_limit integer NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE reset_password_tokens (
	secret bytea NOT NULL,
	owner_id bytea NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE serial_numbers (
	id serial NOT NULL,
	serial_number bytea NOT NULL,
	bucket_id bytea NOT NULL,
	expires_at timestamp NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE storagenode_bandwidth_rollups (
	storagenode_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	interval_seconds integer NOT NULL,
	action integer NOT NULL,
	allocated bigint NOT NULL,
	settled bigint NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start, action )
);
CREATE TABLE storagenode_storage_tallies (
	id bigserial NOT NULL,
	node_id bytea NOT NULL,
	interval_end_time timestamp with time zone NOT NULL,
	data_total double precision NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE users (
	id bytea NOT NULL,
	email text NOT NULL,
	full_name text NOT NULL,
	short_name text,
	password_hash bytea NOT NULL,
	status integer NOT NULL,
	partner_id bytea,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE value_attributions (
	project_id bytea NOT NULL,
	bucket_name bytea NOT NULL,
	partner_id bytea NOT NULL,
	last_updated timestamp NOT NULL,
	PRIMARY KEY ( project_id, bucket_name )
);
CREATE TABLE api_keys (
	id bytea NOT NULL,
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	head bytea NOT NULL,
	name text NOT NULL,
	secret bytea NOT NULL,
	partner_id bytea,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( head ),
	UNIQUE ( name, project_id )
);
CREATE TABLE bucket_metainfos (
	id bytea NOT NULL,
	project_id bytea NOT NULL REFERENCES projects( id ),
	name bytea NOT NULL,
	partner_id bytea,
	path_cipher integer NOT NULL,
	created_at timestamp with time zone NOT NULL,
	default_segment_size integer NOT NULL,
	default_encryption_cipher_suite integer NOT NULL,
	default_encryption_block_size integer NOT NULL,
	default_redundancy_algorithm integer NOT NULL,
	default_redundancy_share_size integer NOT NULL,
	default_redundancy_required_shares integer NOT NULL,
	default_redundancy_repair_shares integer NOT NULL,
	default_redundancy_optimal_shares integer NOT NULL,
	default_redundancy_total_shares integer NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( name, project_id )
);
CREATE TABLE project_invoice_stamps (
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	invoice_id bytea NOT NULL,
	start_date timestamp with time zone NOT NULL,
	end_date timestamp with time zone NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( project_id, start_date, end_date ),
	UNIQUE ( invoice_id )
);
CREATE TABLE project_members (
	member_id bytea NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( member_id, project_id )
);
CREATE TABLE used_serials (
	serial_number_id integer NOT NULL REFERENCES serial_numbers( id ) ON DELETE CASCADE,
	storage_node_id bytea NOT NULL,
	PRIMARY KEY ( serial_number_id, storage_node_id )
);
CREATE TABLE user_credits (
	id serial NOT NULL,
	user_id bytea NOT NULL REFERENCES users( id ),
	offer_id integer NOT NULL REFERENCES offers( id ),
	referred_by bytea REFERENCES users( id ),
	credits_earned_in_cents integer NOT NULL,
	credits_used_in_cents integer NOT NULL,
	expires_at timestamp with time zone NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE user_payments (
	user_id bytea NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	customer_id bytea NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( user_id ),
	UNIQUE ( customer_id )
);
CREATE TABLE project_payments (
	id bytea NOT NULL,
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	payer_id bytea NOT NULL REFERENCES user_payments( user_id ) ON DELETE CASCADE,
	payment_method_id bytea NOT NULL,
	is_default boolean NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE INDEX bucket_name_project_id_interval_start_interval_seconds ON bucket_bandwidth_rollups ( bucket_name, project_id, interval_start, interval_seconds );
CREATE UNIQUE INDEX bucket_id_rollup ON bucket_usages ( bucket_id, rollup_end_time );
CREATE INDEX injuredsegments_attempted_index ON injuredsegments ( attempted );
CREATE INDEX node_last_ip ON nodes ( last_net );
CREATE UNIQUE INDEX serial_number ON serial_numbers ( serial_number );
CREATE INDEX serial_numbers_expires_at_index ON serial_numbers ( expires_at );
CREATE INDEX storagenode_id_interval_start_interval_seconds ON storagenode_bandwidth_rollups ( storagenode_id, interval_start, interval_seconds );`
}

func (obj *postgresDB) wrapTx(tx *sql.Tx) txMethods {
	return &postgresTx{
		dialectTx: dialectTx{tx: tx},
		postgresImpl: &postgresImpl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type postgresTx struct {
	dialectTx
	*postgresImpl
}

func postgresLogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() string {
	return `CREATE TABLE accounting_rollups (
	id INTEGER NOT NULL,
	node_id BLOB NOT NULL,
	start_time TIMESTAMP NOT NULL,
	put_total INTEGER NOT NULL,
	get_total INTEGER NOT NULL,
	get_audit_total INTEGER NOT NULL,
	get_repair_total INTEGER NOT NULL,
	put_repair_total INTEGER NOT NULL,
	at_rest_total REAL NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_timestamps (
	name TEXT NOT NULL,
	value TIMESTAMP NOT NULL,
	PRIMARY KEY ( name )
);
CREATE TABLE bucket_bandwidth_rollups (
	bucket_name BLOB NOT NULL,
	project_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	interval_seconds INTEGER NOT NULL,
	action INTEGER NOT NULL,
	inline INTEGER NOT NULL,
	allocated INTEGER NOT NULL,
	settled INTEGER NOT NULL,
	PRIMARY KEY ( bucket_name, project_id, interval_start, action )
);
CREATE TABLE bucket_storage_tallies (
	bucket_name BLOB NOT NULL,
	project_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	inline INTEGER NOT NULL,
	remote INTEGER NOT NULL,
	remote_segments_count INTEGER NOT NULL,
	inline_segments_count INTEGER NOT NULL,
	object_count INTEGER NOT NULL,
	metadata_size INTEGER NOT NULL,
	PRIMARY KEY ( bucket_name, project_id, interval_start )
);
CREATE TABLE bucket_usages (
	id BLOB NOT NULL,
	bucket_id BLOB NOT NULL,
	rollup_end_time TIMESTAMP NOT NULL,
	remote_stored_data INTEGER NOT NULL,
	inline_stored_data INTEGER NOT NULL,
	remote_segments INTEGER NOT NULL,
	inline_segments INTEGER NOT NULL,
	objects INTEGER NOT NULL,
	metadata_size INTEGER NOT NULL,
	repair_egress INTEGER NOT NULL,
	get_egress INTEGER NOT NULL,
	audit_egress INTEGER NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE certRecords (
	publickey BLOB NOT NULL,
	id BLOB NOT NULL,
	update_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE injuredsegments (
	path BLOB NOT NULL,
	data BLOB NOT NULL,
	attempted TIMESTAMP,
	PRIMARY KEY ( path )
);
CREATE TABLE irreparabledbs (
	segmentpath BLOB NOT NULL,
	segmentdetail BLOB NOT NULL,
	pieces_lost_count INTEGER NOT NULL,
	seg_damaged_unix_sec INTEGER NOT NULL,
	repair_attempt_count INTEGER NOT NULL,
	PRIMARY KEY ( segmentpath )
);
CREATE TABLE nodes (
	id BLOB NOT NULL,
	address TEXT NOT NULL,
	last_net TEXT NOT NULL,
	protocol INTEGER NOT NULL,
	type INTEGER NOT NULL,
	email TEXT NOT NULL,
	wallet TEXT NOT NULL,
	free_bandwidth INTEGER NOT NULL,
	free_disk INTEGER NOT NULL,
	major INTEGER NOT NULL,
	minor INTEGER NOT NULL,
	patch INTEGER NOT NULL,
	hash TEXT NOT NULL,
	timestamp TIMESTAMP NOT NULL,
	release INTEGER NOT NULL,
	latency_90 INTEGER NOT NULL,
	audit_success_count INTEGER NOT NULL,
	total_audit_count INTEGER NOT NULL,
	uptime_success_count INTEGER NOT NULL,
	total_uptime_count INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	last_contact_success TIMESTAMP NOT NULL,
	last_contact_failure TIMESTAMP NOT NULL,
	contained INTEGER NOT NULL,
	disqualified TIMESTAMP,
	audit_reputation_alpha REAL NOT NULL,
	audit_reputation_beta REAL NOT NULL,
	uptime_reputation_alpha REAL NOT NULL,
	uptime_reputation_beta REAL NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE offers (
	id INTEGER NOT NULL,
	name TEXT NOT NULL,
	description TEXT NOT NULL,
	award_credit_in_cents INTEGER NOT NULL,
	invitee_credit_in_cents INTEGER NOT NULL,
	award_credit_duration_days INTEGER,
	invitee_credit_duration_days INTEGER,
	redeemable_cap INTEGER,
	expires_at TIMESTAMP NOT NULL,
	created_at TIMESTAMP NOT NULL,
	status INTEGER NOT NULL,
	type INTEGER NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE pending_audits (
	node_id BLOB NOT NULL,
	piece_id BLOB NOT NULL,
	stripe_index INTEGER NOT NULL,
	share_size INTEGER NOT NULL,
	expected_share_hash BLOB NOT NULL,
	reverify_count INTEGER NOT NULL,
	path BLOB NOT NULL,
	PRIMARY KEY ( node_id )
);
CREATE TABLE projects (
	id BLOB NOT NULL,
	name TEXT NOT NULL,
	description TEXT NOT NULL,
	usage_limit INTEGER NOT NULL,
	partner_id BLOB,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE registration_tokens (
	secret BLOB NOT NULL,
	owner_id BLOB,
	project_limit INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE reset_password_tokens (
	secret BLOB NOT NULL,
	owner_id BLOB NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE serial_numbers (
	id INTEGER NOT NULL,
	serial_number BLOB NOT NULL,
	bucket_id BLOB NOT NULL,
	expires_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE storagenode_bandwidth_rollups (
	storagenode_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	interval_seconds INTEGER NOT NULL,
	action INTEGER NOT NULL,
	allocated INTEGER NOT NULL,
	settled INTEGER NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start, action )
);
CREATE TABLE storagenode_storage_tallies (
	id INTEGER NOT NULL,
	node_id BLOB NOT NULL,
	interval_end_time TIMESTAMP NOT NULL,
	data_total REAL NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE users (
	id BLOB NOT NULL,
	email TEXT NOT NULL,
	full_name TEXT NOT NULL,
	short_name TEXT,
	password_hash BLOB NOT NULL,
	status INTEGER NOT NULL,
	partner_id BLOB,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE value_attributions (
	project_id BLOB NOT NULL,
	bucket_name BLOB NOT NULL,
	partner_id BLOB NOT NULL,
	last_updated TIMESTAMP NOT NULL,
	PRIMARY KEY ( project_id, bucket_name )
);
CREATE TABLE api_keys (
	id BLOB NOT NULL,
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	head BLOB NOT NULL,
	name TEXT NOT NULL,
	secret BLOB NOT NULL,
	partner_id BLOB,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( head ),
	UNIQUE ( name, project_id )
);
CREATE TABLE bucket_metainfos (
	id BLOB NOT NULL,
	project_id BLOB NOT NULL REFERENCES projects( id ),
	name BLOB NOT NULL,
	partner_id BLOB,
	path_cipher INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	default_segment_size INTEGER NOT NULL,
	default_encryption_cipher_suite INTEGER NOT NULL,
	default_encryption_block_size INTEGER NOT NULL,
	default_redundancy_algorithm INTEGER NOT NULL,
	default_redundancy_share_size INTEGER NOT NULL,
	default_redundancy_required_shares INTEGER NOT NULL,
	default_redundancy_repair_shares INTEGER NOT NULL,
	default_redundancy_optimal_shares INTEGER NOT NULL,
	default_redundancy_total_shares INTEGER NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( name, project_id )
);
CREATE TABLE project_invoice_stamps (
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	invoice_id BLOB NOT NULL,
	start_date TIMESTAMP NOT NULL,
	end_date TIMESTAMP NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( project_id, start_date, end_date ),
	UNIQUE ( invoice_id )
);
CREATE TABLE project_members (
	member_id BLOB NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( member_id, project_id )
);
CREATE TABLE used_serials (
	serial_number_id INTEGER NOT NULL REFERENCES serial_numbers( id ) ON DELETE CASCADE,
	storage_node_id BLOB NOT NULL,
	PRIMARY KEY ( serial_number_id, storage_node_id )
);
CREATE TABLE user_credits (
	id INTEGER NOT NULL,
	user_id BLOB NOT NULL REFERENCES users( id ),
	offer_id INTEGER NOT NULL REFERENCES offers( id ),
	referred_by BLOB REFERENCES users( id ),
	credits_earned_in_cents INTEGER NOT NULL,
	credits_used_in_cents INTEGER NOT NULL,
	expires_at TIMESTAMP NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE user_payments (
	user_id BLOB NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	customer_id BLOB NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( user_id ),
	UNIQUE ( customer_id )
);
CREATE TABLE project_payments (
	id BLOB NOT NULL,
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	payer_id BLOB NOT NULL REFERENCES user_payments( user_id ) ON DELETE CASCADE,
	payment_method_id BLOB NOT NULL,
	is_default INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE INDEX bucket_name_project_id_interval_start_interval_seconds ON bucket_bandwidth_rollups ( bucket_name, project_id, interval_start, interval_seconds );
CREATE UNIQUE INDEX bucket_id_rollup ON bucket_usages ( bucket_id, rollup_end_time );
CREATE INDEX injuredsegments_attempted_index ON injuredsegments ( attempted );
CREATE INDEX node_last_ip ON nodes ( last_net );
CREATE UNIQUE INDEX serial_number ON serial_numbers ( serial_number );
CREATE INDEX serial_numbers_expires_at_index ON serial_numbers ( expires_at );
CREATE INDEX storagenode_id_interval_start_interval_seconds ON storagenode_bandwidth_rollups ( storagenode_id, interval_start, interval_seconds );`
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type AccountingRollup struct {
	Id             int64
	NodeId         []byte
	StartTime      time.Time
	PutTotal       int64
	GetTotal       int64
	GetAuditTotal  int64
	GetRepairTotal int64
	PutRepairTotal int64
	AtRestTotal    float64
}

func (AccountingRollup) _Table() string { return "accounting_rollups" }

type AccountingRollup_Update_Fields struct {
}

type AccountingRollup_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_Id(v int64) AccountingRollup_Id_Field {
	return AccountingRollup_Id_Field{_set: true, _value: v}
}

func (f AccountingRollup_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_Id_Field) _Column() string { return "id" }

type AccountingRollup_NodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func AccountingRollup_NodeId(v []byte) AccountingRollup_NodeId_Field {
	return AccountingRollup_NodeId_Field{_set: true, _value: v}
}

func (f AccountingRollup_NodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_NodeId_Field) _Column() string { return "node_id" }

type AccountingRollup_StartTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingRollup_StartTime(v time.Time) AccountingRollup_StartTime_Field {
	return AccountingRollup_StartTime_Field{_set: true, _value: v}
}

func (f AccountingRollup_StartTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_StartTime_Field) _Column() string { return "start_time" }

type AccountingRollup_PutTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_PutTotal(v int64) AccountingRollup_PutTotal_Field {
	return AccountingRollup_PutTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_PutTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_PutTotal_Field) _Column() string { return "put_total" }

type AccountingRollup_GetTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetTotal(v int64) AccountingRollup_GetTotal_Field {
	return AccountingRollup_GetTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetTotal_Field) _Column() string { return "get_total" }

type AccountingRollup_GetAuditTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetAuditTotal(v int64) AccountingRollup_GetAuditTotal_Field {
	return AccountingRollup_GetAuditTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetAuditTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetAuditTotal_Field) _Column() string { return "get_audit_total" }

type AccountingRollup_GetRepairTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetRepairTotal(v int64) AccountingRollup_GetRepairTotal_Field {
	return AccountingRollup_GetRepairTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetRepairTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetRepairTotal_Field) _Column() string { return "get_repair_total" }

type AccountingRollup_PutRepairTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_PutRepairTotal(v int64) AccountingRollup_PutRepairTotal_Field {
	return AccountingRollup_PutRepairTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_PutRepairTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_PutRepairTotal_Field) _Column() string { return "put_repair_total" }

type AccountingRollup_AtRestTotal_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func AccountingRollup_AtRestTotal(v float64) AccountingRollup_AtRestTotal_Field {
	return AccountingRollup_AtRestTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_AtRestTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_AtRestTotal_Field) _Column() string { return "at_rest_total" }

type AccountingTimestamps struct {
	Name  string
	Value time.Time
}

func (AccountingTimestamps) _Table() string { return "accounting_timestamps" }

type AccountingTimestamps_Update_Fields struct {
	Value AccountingTimestamps_Value_Field
}

type AccountingTimestamps_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func AccountingTimestamps_Name(v string) AccountingTimestamps_Name_Field {
	return AccountingTimestamps_Name_Field{_set: true, _value: v}
}

func (f AccountingTimestamps_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingTimestamps_Name_Field) _Column() string { return "name" }

type AccountingTimestamps_Value_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingTimestamps_Value(v time.Time) AccountingTimestamps_Value_Field {
	return AccountingTimestamps_Value_Field{_set: true, _value: v}
}

func (f AccountingTimestamps_Value_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingTimestamps_Value_Field) _Column() string { return "value" }

type BucketBandwidthRollup struct {
	BucketName      []byte
	ProjectId       []byte
	IntervalStart   time.Time
	IntervalSeconds uint
	Action          uint
	Inline          uint64
	Allocated       uint64
	Settled         uint64
}

func (BucketBandwidthRollup) _Table() string { return "bucket_bandwidth_rollups" }

type BucketBandwidthRollup_Update_Fields struct {
	Inline    BucketBandwidthRollup_Inline_Field
	Allocated BucketBandwidthRollup_Allocated_Field
	Settled   BucketBandwidthRollup_Settled_Field
}

type BucketBandwidthRollup_BucketName_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketBandwidthRollup_BucketName(v []byte) BucketBandwidthRollup_BucketName_Field {
	return BucketBandwidthRollup_BucketName_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_BucketName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_BucketName_Field) _Column() string { return "bucket_name" }

type BucketBandwidthRollup_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketBandwidthRollup_ProjectId(v []byte) BucketBandwidthRollup_ProjectId_Field {
	return BucketBandwidthRollup_ProjectId_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_ProjectId_Field) _Column() string { return "project_id" }

type BucketBandwidthRollup_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketBandwidthRollup_IntervalStart(v time.Time) BucketBandwidthRollup_IntervalStart_Field {
	v = toUTC(v)
	return BucketBandwidthRollup_IntervalStart_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_IntervalStart_Field) _Column() string { return "interval_start" }

type BucketBandwidthRollup_IntervalSeconds_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketBandwidthRollup_IntervalSeconds(v uint) BucketBandwidthRollup_IntervalSeconds_Field {
	return BucketBandwidthRollup_IntervalSeconds_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_IntervalSeconds_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_IntervalSeconds_Field) _Column() string { return "interval_seconds" }

type BucketBandwidthRollup_Action_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketBandwidthRollup_Action(v uint) BucketBandwidthRollup_Action_Field {
	return BucketBandwidthRollup_Action_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Action_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Action_Field) _Column() string { return "action" }

type BucketBandwidthRollup_Inline_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Inline(v uint64) BucketBandwidthRollup_Inline_Field {
	return BucketBandwidthRollup_Inline_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Inline_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Inline_Field) _Column() string { return "inline" }

type BucketBandwidthRollup_Allocated_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Allocated(v uint64) BucketBandwidthRollup_Allocated_Field {
	return BucketBandwidthRollup_Allocated_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Allocated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Allocated_Field) _Column() string { return "allocated" }

type BucketBandwidthRollup_Settled_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Settled(v uint64) BucketBandwidthRollup_Settled_Field {
	return BucketBandwidthRollup_Settled_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Settled_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Settled_Field) _Column() string { return "settled" }

type BucketStorageTally struct {
	BucketName          []byte
	ProjectId           []byte
	IntervalStart       time.Time
	Inline              uint64
	Remote              uint64
	RemoteSegmentsCount uint
	InlineSegmentsCount uint
	ObjectCount         uint
	MetadataSize        uint64
}

func (BucketStorageTally) _Table() string { return "bucket_storage_tallies" }

type BucketStorageTally_Update_Fields struct {
}

type BucketStorageTally_BucketName_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketStorageTally_BucketName(v []byte) BucketStorageTally_BucketName_Field {
	return BucketStorageTally_BucketName_Field{_set: true, _value: v}
}

func (f BucketStorageTally_BucketName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_BucketName_Field) _Column() string { return "bucket_name" }

type BucketStorageTally_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketStorageTally_ProjectId(v []byte) BucketStorageTally_ProjectId_Field {
	return BucketStorageTally_ProjectId_Field{_set: true, _value: v}
}

func (f BucketStorageTally_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_ProjectId_Field) _Column() string { return "project_id" }

type BucketStorageTally_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketStorageTally_IntervalStart(v time.Time) BucketStorageTally_IntervalStart_Field {
	v = toUTC(v)
	return BucketStorageTally_IntervalStart_Field{_set: true, _value: v}
}

func (f BucketStorageTally_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_IntervalStart_Field) _Column() string { return "interval_start" }

type BucketStorageTally_Inline_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_Inline(v uint64) BucketStorageTally_Inline_Field {
	return BucketStorageTally_Inline_Field{_set: true, _value: v}
}

func (f BucketStorageTally_Inline_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_Inline_Field) _Column() string { return "inline" }

type BucketStorageTally_Remote_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_Remote(v uint64) BucketStorageTally_Remote_Field {
	return BucketStorageTally_Remote_Field{_set: true, _value: v}
}

func (f BucketStorageTally_Remote_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_Remote_Field) _Column() string { return "remote" }

type BucketStorageTally_RemoteSegmentsCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_RemoteSegmentsCount(v uint) BucketStorageTally_RemoteSegmentsCount_Field {
	return BucketStorageTally_RemoteSegmentsCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_RemoteSegmentsCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_RemoteSegmentsCount_Field) _Column() string { return "remote_segments_count" }

type BucketStorageTally_InlineSegmentsCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_InlineSegmentsCount(v uint) BucketStorageTally_InlineSegmentsCount_Field {
	return BucketStorageTally_InlineSegmentsCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_InlineSegmentsCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_InlineSegmentsCount_Field) _Column() string { return "inline_segments_count" }

type BucketStorageTally_ObjectCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_ObjectCount(v uint) BucketStorageTally_ObjectCount_Field {
	return BucketStorageTally_ObjectCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_ObjectCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_ObjectCount_Field) _Column() string { return "object_count" }

type BucketStorageTally_MetadataSize_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_MetadataSize(v uint64) BucketStorageTally_MetadataSize_Field {
	return BucketStorageTally_MetadataSize_Field{_set: true, _value: v}
}

func (f BucketStorageTally_MetadataSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_MetadataSize_Field) _Column() string { return "metadata_size" }

type BucketUsage struct {
	Id               []byte
	BucketId         []byte
	RollupEndTime    time.Time
	RemoteStoredData uint64
	InlineStoredData uint64
	RemoteSegments   uint
	InlineSegments   uint
	Objects          uint
	MetadataSize     uint64
	RepairEgress     uint64
	GetEgress        uint64
	AuditEgress      uint64
}

func (BucketUsage) _Table() string { return "bucket_usages" }

type BucketUsage_Update_Fields struct {
}

type BucketUsage_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketUsage_Id(v []byte) BucketUsage_Id_Field {
	return BucketUsage_Id_Field{_set: true, _value: v}
}

func (f BucketUsage_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_Id_Field) _Column() string { return "id" }

type BucketUsage_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketUsage_BucketId(v []byte) BucketUsage_BucketId_Field {
	return BucketUsage_BucketId_Field{_set: true, _value: v}
}

func (f BucketUsage_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_BucketId_Field) _Column() string { return "bucket_id" }

type BucketUsage_RollupEndTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketUsage_RollupEndTime(v time.Time) BucketUsage_RollupEndTime_Field {
	return BucketUsage_RollupEndTime_Field{_set: true, _value: v}
}

func (f BucketUsage_RollupEndTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RollupEndTime_Field) _Column() string { return "rollup_end_time" }

type BucketUsage_RemoteStoredData_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_RemoteStoredData(v uint64) BucketUsage_RemoteStoredData_Field {
	return BucketUsage_RemoteStoredData_Field{_set: true, _value: v}
}

func (f BucketUsage_RemoteStoredData_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RemoteStoredData_Field) _Column() string { return "remote_stored_data" }

type BucketUsage_InlineStoredData_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_InlineStoredData(v uint64) BucketUsage_InlineStoredData_Field {
	return BucketUsage_InlineStoredData_Field{_set: true, _value: v}
}

func (f BucketUsage_InlineStoredData_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_InlineStoredData_Field) _Column() string { return "inline_stored_data" }

type BucketUsage_RemoteSegments_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_RemoteSegments(v uint) BucketUsage_RemoteSegments_Field {
	return BucketUsage_RemoteSegments_Field{_set: true, _value: v}
}

func (f BucketUsage_RemoteSegments_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RemoteSegments_Field) _Column() string { return "remote_segments" }

type BucketUsage_InlineSegments_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_InlineSegments(v uint) BucketUsage_InlineSegments_Field {
	return BucketUsage_InlineSegments_Field{_set: true, _value: v}
}

func (f BucketUsage_InlineSegments_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_InlineSegments_Field) _Column() string { return "inline_segments" }

type BucketUsage_Objects_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_Objects(v uint) BucketUsage_Objects_Field {
	return BucketUsage_Objects_Field{_set: true, _value: v}
}

func (f BucketUsage_Objects_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_Objects_Field) _Column() string { return "objects" }

type BucketUsage_MetadataSize_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_MetadataSize(v uint64) BucketUsage_MetadataSize_Field {
	return BucketUsage_MetadataSize_Field{_set: true, _value: v}
}

func (f BucketUsage_MetadataSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_MetadataSize_Field) _Column() string { return "metadata_size" }

type BucketUsage_RepairEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_RepairEgress(v uint64) BucketUsage_RepairEgress_Field {
	return BucketUsage_RepairEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_RepairEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RepairEgress_Field) _Column() string { return "repair_egress" }

type BucketUsage_GetEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_GetEgress(v uint64) BucketUsage_GetEgress_Field {
	return BucketUsage_GetEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_GetEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_GetEgress_Field) _Column() string { return "get_egress" }

type BucketUsage_AuditEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_AuditEgress(v uint64) BucketUsage_AuditEgress_Field {
	return BucketUsage_AuditEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_AuditEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_AuditEgress_Field) _Column() string { return "audit_egress" }

type CertRecord struct {
	Publickey []byte
	Id        []byte
	UpdateAt  time.Time
}

func (CertRecord) _Table() string { return "certRecords" }

type CertRecord_Update_Fields struct {
}

type CertRecord_Publickey_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func CertRecord_Publickey(v []byte) CertRecord_Publickey_Field {
	return CertRecord_Publickey_Field{_set: true, _value: v}
}

func (f CertRecord_Publickey_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_Publickey_Field) _Column() string { return "publickey" }

type CertRecord_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func CertRecord_Id(v []byte) CertRecord_Id_Field {
	return CertRecord_Id_Field{_set: true, _value: v}
}

func (f CertRecord_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_Id_Field) _Column() string { return "id" }

type CertRecord_UpdateAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func CertRecord_UpdateAt(v time.Time) CertRecord_UpdateAt_Field {
	return CertRecord_UpdateAt_Field{_set: true, _value: v}
}

func (f CertRecord_UpdateAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_UpdateAt_Field) _Column() string { return "update_at" }

type Injuredsegment struct {
	Path      []byte
	Data      []byte
	Attempted *time.Time
}

func (Injuredsegment) _Table() string { return "injuredsegments" }

type Injuredsegment_Create_Fields struct {
	Attempted Injuredsegment_Attempted_Field
}

type Injuredsegment_Update_Fields struct {
	Attempted Injuredsegment_Attempted_Field
}

type Injuredsegment_Path_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Injuredsegment_Path(v []byte) Injuredsegment_Path_Field {
	return Injuredsegment_Path_Field{_set: true, _value: v}
}

func (f Injuredsegment_Path_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Injuredsegment_Path_Field) _Column() string { return "path" }

type Injuredsegment_Data_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Injuredsegment_Data(v []byte) Injuredsegment_Data_Field {
	return Injuredsegment_Data_Field{_set: true, _value: v}
}

func (f Injuredsegment_Data_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Injuredsegment_Data_Field) _Column() string { return "data" }

type Injuredsegment_Attempted_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func Injuredsegment_Attempted(v time.Time) Injuredsegment_Attempted_Field {
	v = toUTC(v)
	return Injuredsegment_Attempted_Field{_set: true, _value: &v}
}

func Injuredsegment_Attempted_Raw(v *time.Time) Injuredsegment_Attempted_Field {
	if v == nil {
		return Injuredsegment_Attempted_Null()
	}
	return Injuredsegment_Attempted(*v)
}

func Injuredsegment_Attempted_Null() Injuredsegment_Attempted_Field {
	return Injuredsegment_Attempted_Field{_set: true, _null: true}
}

func (f Injuredsegment_Attempted_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Injuredsegment_Attempted_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Injuredsegment_Attempted_Field) _Column() string { return "attempted" }

type Irreparabledb struct {
	Segmentpath        []byte
	Segmentdetail      []byte
	PiecesLostCount    int64
	SegDamagedUnixSec  int64
	RepairAttemptCount int64
}

func (Irreparabledb) _Table() string { return "irreparabledbs" }

type Irreparabledb_Update_Fields struct {
	Segmentdetail      Irreparabledb_Segmentdetail_Field
	PiecesLostCount    Irreparabledb_PiecesLostCount_Field
	SegDamagedUnixSec  Irreparabledb_SegDamagedUnixSec_Field
	RepairAttemptCount Irreparabledb_RepairAttemptCount_Field
}

type Irreparabledb_Segmentpath_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Irreparabledb_Segmentpath(v []byte) Irreparabledb_Segmentpath_Field {
	return Irreparabledb_Segmentpath_Field{_set: true, _value: v}
}

func (f Irreparabledb_Segmentpath_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_Segmentpath_Field) _Column() string { return "segmentpath" }

type Irreparabledb_Segmentdetail_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Irreparabledb_Segmentdetail(v []byte) Irreparabledb_Segmentdetail_Field {
	return Irreparabledb_Segmentdetail_Field{_set: true, _value: v}
}

func (f Irreparabledb_Segmentdetail_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_Segmentdetail_Field) _Column() string { return "segmentdetail" }

type Irreparabledb_PiecesLostCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_PiecesLostCount(v int64) Irreparabledb_PiecesLostCount_Field {
	return Irreparabledb_PiecesLostCount_Field{_set: true, _value: v}
}

func (f Irreparabledb_PiecesLostCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_PiecesLostCount_Field) _Column() string { return "pieces_lost_count" }

type Irreparabledb_SegDamagedUnixSec_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_SegDamagedUnixSec(v int64) Irreparabledb_SegDamagedUnixSec_Field {
	return Irreparabledb_SegDamagedUnixSec_Field{_set: true, _value: v}
}

func (f Irreparabledb_SegDamagedUnixSec_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_SegDamagedUnixSec_Field) _Column() string { return "seg_damaged_unix_sec" }

type Irreparabledb_RepairAttemptCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_RepairAttemptCount(v int64) Irreparabledb_RepairAttemptCount_Field {
	return Irreparabledb_RepairAttemptCount_Field{_set: true, _value: v}
}

func (f Irreparabledb_RepairAttemptCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_RepairAttemptCount_Field) _Column() string { return "repair_attempt_count" }

type Node struct {
	Id                    []byte
	Address               string
	LastNet               string
	Protocol              int
	Type                  int
	Email                 string
	Wallet                string
	FreeBandwidth         int64
	FreeDisk              int64
	Major                 int64
	Minor                 int64
	Patch                 int64
	Hash                  string
	Timestamp             time.Time
	Release               bool
	Latency90             int64
	AuditSuccessCount     int64
	TotalAuditCount       int64
	UptimeSuccessCount    int64
	TotalUptimeCount      int64
	CreatedAt             time.Time
	UpdatedAt             time.Time
	LastContactSuccess    time.Time
	LastContactFailure    time.Time
	Contained             bool
	Disqualified          *time.Time
	AuditReputationAlpha  float64
	AuditReputationBeta   float64
	UptimeReputationAlpha float64
	UptimeReputationBeta  float64
}

func (Node) _Table() string { return "nodes" }

type Node_Create_Fields struct {
	Disqualified Node_Disqualified_Field
}

type Node_Update_Fields struct {
	Address               Node_Address_Field
	LastNet               Node_LastNet_Field
	Protocol              Node_Protocol_Field
	Type                  Node_Type_Field
	Email                 Node_Email_Field
	Wallet                Node_Wallet_Field
	FreeBandwidth         Node_FreeBandwidth_Field
	FreeDisk              Node_FreeDisk_Field
	Major                 Node_Major_Field
	Minor                 Node_Minor_Field
	Patch                 Node_Patch_Field
	Hash                  Node_Hash_Field
	Timestamp             Node_Timestamp_Field
	Release               Node_Release_Field
	Latency90             Node_Latency90_Field
	AuditSuccessCount     Node_AuditSuccessCount_Field
	TotalAuditCount       Node_TotalAuditCount_Field
	UptimeSuccessCount    Node_UptimeSuccessCount_Field
	TotalUptimeCount      Node_TotalUptimeCount_Field
	LastContactSuccess    Node_LastContactSuccess_Field
	LastContactFailure    Node_LastContactFailure_Field
	Contained             Node_Contained_Field
	Disqualified          Node_Disqualified_Field
	AuditReputationAlpha  Node_AuditReputationAlpha_Field
	AuditReputationBeta   Node_AuditReputationBeta_Field
	UptimeReputationAlpha Node_UptimeReputationAlpha_Field
	UptimeReputationBeta  Node_UptimeReputationBeta_Field
}

type Node_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Node_Id(v []byte) Node_Id_Field {
	return Node_Id_Field{_set: true, _value: v}
}

func (f Node_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Id_Field) _Column() string { return "id" }

type Node_Address_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Address(v string) Node_Address_Field {
	return Node_Address_Field{_set: true, _value: v}
}

func (f Node_Address_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Address_Field) _Column() string { return "address" }

type Node_LastNet_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_LastNet(v string) Node_LastNet_Field {
	return Node_LastNet_Field{_set: true, _value: v}
}

func (f Node_LastNet_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_LastNet_Field) _Column() string { return "last_net" }

type Node_Protocol_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Node_Protocol(v int) Node_Protocol_Field {
	return Node_Protocol_Field{_set: true, _value: v}
}

func (f Node_Protocol_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Protocol_Field) _Column() string { return "protocol" }

type Node_Type_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Node_Type(v int) Node_Type_Field {
	return Node_Type_Field{_set: true, _value: v}
}

func (f Node_Type_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Type_Field) _Column() string { return "type" }

type Node_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Email(v string) Node_Email_Field {
	return Node_Email_Field{_set: true, _value: v}
}

func (f Node_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Email_Field) _Column() string { return "email" }

type Node_Wallet_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Wallet(v string) Node_Wallet_Field {
	return Node_Wallet_Field{_set: true, _value: v}
}

func (f Node_Wallet_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Wallet_Field) _Column() string { return "wallet" }

type Node_FreeBandwidth_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_FreeBandwidth(v int64) Node_FreeBandwidth_Field {
	return Node_FreeBandwidth_Field{_set: true, _value: v}
}

func (f Node_FreeBandwidth_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_FreeBandwidth_Field) _Column() string { return "free_bandwidth" }

type Node_FreeDisk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_FreeDisk(v int64) Node_FreeDisk_Field {
	return Node_FreeDisk_Field{_set: true, _value: v}
}

func (f Node_FreeDisk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_FreeDisk_Field) _Column() string { return "free_disk" }

type Node_Major_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Major(v int64) Node_Major_Field {
	return Node_Major_Field{_set: true, _value: v}
}

func (f Node_Major_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Major_Field) _Column() string { return "major" }

type Node_Minor_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Minor(v int64) Node_Minor_Field {
	return Node_Minor_Field{_set: true, _value: v}
}

func (f Node_Minor_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Minor_Field) _Column() string { return "minor" }

type Node_Patch_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Patch(v int64) Node_Patch_Field {
	return Node_Patch_Field{_set: true, _value: v}
}

func (f Node_Patch_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Patch_Field) _Column() string { return "patch" }

type Node_Hash_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Hash(v string) Node_Hash_Field {
	return Node_Hash_Field{_set: true, _value: v}
}

func (f Node_Hash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Hash_Field) _Column() string { return "hash" }

type Node_Timestamp_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_Timestamp(v time.Time) Node_Timestamp_Field {
	return Node_Timestamp_Field{_set: true, _value: v}
}

func (f Node_Timestamp_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Timestamp_Field) _Column() string { return "timestamp" }

type Node_Release_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func Node_Release(v bool) Node_Release_Field {
	return Node_Release_Field{_set: true, _value: v}
}

func (f Node_Release_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Release_Field) _Column() string { return "release" }

type Node_Latency90_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Latency90(v int64) Node_Latency90_Field {
	return Node_Latency90_Field{_set: true, _value: v}
}

func (f Node_Latency90_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Latency90_Field) _Column() string { return "latency_90" }

type Node_AuditSuccessCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_AuditSuccessCount(v int64) Node_AuditSuccessCount_Field {
	return Node_AuditSuccessCount_Field{_set: true, _value: v}
}

func (f Node_AuditSuccessCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_AuditSuccessCount_Field) _Column() string { return "audit_success_count" }

type Node_TotalAuditCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_TotalAuditCount(v int64) Node_TotalAuditCount_Field {
	return Node_TotalAuditCount_Field{_set: true, _value: v}
}

func (f Node_TotalAuditCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_TotalAuditCount_Field) _Column() string { return "total_audit_count" }

type Node_UptimeSuccessCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_UptimeSuccessCount(v int64) Node_UptimeSuccessCount_Field {
	return Node_UptimeSuccessCount_Field{_set: true, _value: v}
}

func (f Node_UptimeSuccessCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UptimeSuccessCount_Field) _Column() string { return "uptime_success_count" }

type Node_TotalUptimeCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_TotalUptimeCount(v int64) Node_TotalUptimeCount_Field {
	return Node_TotalUptimeCount_Field{_set: true, _value: v}
}

func (f Node_TotalUptimeCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_TotalUptimeCount_Field) _Column() string { return "total_uptime_count" }

type Node_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_CreatedAt(v time.Time) Node_CreatedAt_Field {
	return Node_CreatedAt_Field{_set: true, _value: v}
}

func (f Node_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_CreatedAt_Field) _Column() string { return "created_at" }

type Node_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_UpdatedAt(v time.Time) Node_UpdatedAt_Field {
	return Node_UpdatedAt_Field{_set: true, _value: v}
}

func (f Node_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UpdatedAt_Field) _Column() string { return "updated_at" }

type Node_LastContactSuccess_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_LastContactSuccess(v time.Time) Node_LastContactSuccess_Field {
	return Node_LastContactSuccess_Field{_set: true, _value: v}
}

func (f Node_LastContactSuccess_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_LastContactSuccess_Field) _Column() string { return "last_contact_success" }

type Node_LastContactFailure_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_LastContactFailure(v time.Time) Node_LastContactFailure_Field {
	return Node_LastContactFailure_Field{_set: true, _value: v}
}

func (f Node_LastContactFailure_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_LastContactFailure_Field) _Column() string { return "last_contact_failure" }

type Node_Contained_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func Node_Contained(v bool) Node_Contained_Field {
	return Node_Contained_Field{_set: true, _value: v}
}

func (f Node_Contained_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Contained_Field) _Column() string { return "contained" }

type Node_Disqualified_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func Node_Disqualified(v time.Time) Node_Disqualified_Field {
	return Node_Disqualified_Field{_set: true, _value: &v}
}

func Node_Disqualified_Raw(v *time.Time) Node_Disqualified_Field {
	if v == nil {
		return Node_Disqualified_Null()
	}
	return Node_Disqualified(*v)
}

func Node_Disqualified_Null() Node_Disqualified_Field {
	return Node_Disqualified_Field{_set: true, _null: true}
}

func (f Node_Disqualified_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Node_Disqualified_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Disqualified_Field) _Column() string { return "disqualified" }

type Node_AuditReputationAlpha_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_AuditReputationAlpha(v float64) Node_AuditReputationAlpha_Field {
	return Node_AuditReputationAlpha_Field{_set: true, _value: v}
}

func (f Node_AuditReputationAlpha_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_AuditReputationAlpha_Field) _Column() string { return "audit_reputation_alpha" }

type Node_AuditReputationBeta_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_AuditReputationBeta(v float64) Node_AuditReputationBeta_Field {
	return Node_AuditReputationBeta_Field{_set: true, _value: v}
}

func (f Node_AuditReputationBeta_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_AuditReputationBeta_Field) _Column() string { return "audit_reputation_beta" }

type Node_UptimeReputationAlpha_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_UptimeReputationAlpha(v float64) Node_UptimeReputationAlpha_Field {
	return Node_UptimeReputationAlpha_Field{_set: true, _value: v}
}

func (f Node_UptimeReputationAlpha_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UptimeReputationAlpha_Field) _Column() string { return "uptime_reputation_alpha" }

type Node_UptimeReputationBeta_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_UptimeReputationBeta(v float64) Node_UptimeReputationBeta_Field {
	return Node_UptimeReputationBeta_Field{_set: true, _value: v}
}

func (f Node_UptimeReputationBeta_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UptimeReputationBeta_Field) _Column() string { return "uptime_reputation_beta" }

type Offer struct {
	Id                        int
	Name                      string
	Description               string
	AwardCreditInCents        int
	InviteeCreditInCents      int
	AwardCreditDurationDays   *int
	InviteeCreditDurationDays *int
	RedeemableCap             *int
	ExpiresAt                 time.Time
	CreatedAt                 time.Time
	Status                    int
	Type                      int
}

func (Offer) _Table() string { return "offers" }

type Offer_Create_Fields struct {
	AwardCreditDurationDays   Offer_AwardCreditDurationDays_Field
	InviteeCreditDurationDays Offer_InviteeCreditDurationDays_Field
	RedeemableCap             Offer_RedeemableCap_Field
}

type Offer_Update_Fields struct {
	Name                      Offer_Name_Field
	Description               Offer_Description_Field
	AwardCreditInCents        Offer_AwardCreditInCents_Field
	InviteeCreditInCents      Offer_InviteeCreditInCents_Field
	AwardCreditDurationDays   Offer_AwardCreditDurationDays_Field
	InviteeCreditDurationDays Offer_InviteeCreditDurationDays_Field
	RedeemableCap             Offer_RedeemableCap_Field
	ExpiresAt                 Offer_ExpiresAt_Field
	Status                    Offer_Status_Field
	Type                      Offer_Type_Field
}

type Offer_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Offer_Id(v int) Offer_Id_Field {
	return Offer_Id_Field{_set: true, _value: v}
}

func (f Offer_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_Id_Field) _Column() string { return "id" }

type Offer_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Offer_Name(v string) Offer_Name_Field {
	return Offer_Name_Field{_set: true, _value: v}
}

func (f Offer_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_Name_Field) _Column() string { return "name" }

type Offer_Description_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Offer_Description(v string) Offer_Description_Field {
	return Offer_Description_Field{_set: true, _value: v}
}

func (f Offer_Description_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_Description_Field) _Column() string { return "description" }

type Offer_AwardCreditInCents_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Offer_AwardCreditInCents(v int) Offer_AwardCreditInCents_Field {
	return Offer_AwardCreditInCents_Field{_set: true, _value: v}
}

func (f Offer_AwardCreditInCents_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_AwardCreditInCents_Field) _Column() string { return "award_credit_in_cents" }

type Offer_InviteeCreditInCents_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Offer_InviteeCreditInCents(v int) Offer_InviteeCreditInCents_Field {
	return Offer_InviteeCreditInCents_Field{_set: true, _value: v}
}

func (f Offer_InviteeCreditInCents_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_InviteeCreditInCents_Field) _Column() string { return "invitee_credit_in_cents" }

type Offer_AwardCreditDurationDays_Field struct {
	_set   bool
	_null  bool
	_value *int
}

func Offer_AwardCreditDurationDays(v int) Offer_AwardCreditDurationDays_Field {
	return Offer_AwardCreditDurationDays_Field{_set: true, _value: &v}
}

func Offer_AwardCreditDurationDays_Raw(v *int) Offer_AwardCreditDurationDays_Field {
	if v == nil {
		return Offer_AwardCreditDurationDays_Null()
	}
	return Offer_AwardCreditDurationDays(*v)
}

func Offer_AwardCreditDurationDays_Null() Offer_AwardCreditDurationDays_Field {
	return Offer_AwardCreditDurationDays_Field{_set: true, _null: true}
}

func (f Offer_AwardCreditDurationDays_Field) isnull() bool {
	return !f._set || f._null || f._value == nil
}

func (f Offer_AwardCreditDurationDays_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_AwardCreditDurationDays_Field) _Column() string { return "award_credit_duration_days" }

type Offer_InviteeCreditDurationDays_Field struct {
	_set   bool
	_null  bool
	_value *int
}

func Offer_InviteeCreditDurationDays(v int) Offer_InviteeCreditDurationDays_Field {
	return Offer_InviteeCreditDurationDays_Field{_set: true, _value: &v}
}

func Offer_InviteeCreditDurationDays_Raw(v *int) Offer_InviteeCreditDurationDays_Field {
	if v == nil {
		return Offer_InviteeCreditDurationDays_Null()
	}
	return Offer_InviteeCreditDurationDays(*v)
}

func Offer_InviteeCreditDurationDays_Null() Offer_InviteeCreditDurationDays_Field {
	return Offer_InviteeCreditDurationDays_Field{_set: true, _null: true}
}

func (f Offer_InviteeCreditDurationDays_Field) isnull() bool {
	return !f._set || f._null || f._value == nil
}

func (f Offer_InviteeCreditDurationDays_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_InviteeCreditDurationDays_Field) _Column() string { return "invitee_credit_duration_days" }

type Offer_RedeemableCap_Field struct {
	_set   bool
	_null  bool
	_value *int
}

func Offer_RedeemableCap(v int) Offer_RedeemableCap_Field {
	return Offer_RedeemableCap_Field{_set: true, _value: &v}
}

func Offer_RedeemableCap_Raw(v *int) Offer_RedeemableCap_Field {
	if v == nil {
		return Offer_RedeemableCap_Null()
	}
	return Offer_RedeemableCap(*v)
}

func Offer_RedeemableCap_Null() Offer_RedeemableCap_Field {
	return Offer_RedeemableCap_Field{_set: true, _null: true}
}

func (f Offer_RedeemableCap_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Offer_RedeemableCap_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_RedeemableCap_Field) _Column() string { return "redeemable_cap" }

type Offer_ExpiresAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Offer_ExpiresAt(v time.Time) Offer_ExpiresAt_Field {
	return Offer_ExpiresAt_Field{_set: true, _value: v}
}

func (f Offer_ExpiresAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_ExpiresAt_Field) _Column() string { return "expires_at" }

type Offer_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Offer_CreatedAt(v time.Time) Offer_CreatedAt_Field {
	return Offer_CreatedAt_Field{_set: true, _value: v}
}

func (f Offer_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_CreatedAt_Field) _Column() string { return "created_at" }

type Offer_Status_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Offer_Status(v int) Offer_Status_Field {
	return Offer_Status_Field{_set: true, _value: v}
}

func (f Offer_Status_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_Status_Field) _Column() string { return "status" }

type Offer_Type_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Offer_Type(v int) Offer_Type_Field {
	return Offer_Type_Field{_set: true, _value: v}
}

func (f Offer_Type_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Offer_Type_Field) _Column() string { return "type" }

type PendingAudits struct {
	NodeId            []byte
	PieceId           []byte
	StripeIndex       int64
	ShareSize         int64
	ExpectedShareHash []byte
	ReverifyCount     int64
	Path              []byte
}

func (PendingAudits) _Table() string { return "pending_audits" }

type PendingAudits_Update_Fields struct {
	ReverifyCount PendingAudits_ReverifyCount_Field
}

type PendingAudits_NodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func PendingAudits_NodeId(v []byte) PendingAudits_NodeId_Field {
	return PendingAudits_NodeId_Field{_set: true, _value: v}
}

func (f PendingAudits_NodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_NodeId_Field) _Column() string { return "node_id" }

type PendingAudits_PieceId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func PendingAudits_PieceId(v []byte) PendingAudits_PieceId_Field {
	return PendingAudits_PieceId_Field{_set: true, _value: v}
}

func (f PendingAudits_PieceId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_PieceId_Field) _Column() string { return "piece_id" }

type PendingAudits_StripeIndex_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func PendingAudits_StripeIndex(v int64) PendingAudits_StripeIndex_Field {
	return PendingAudits_StripeIndex_Field{_set: true, _value: v}
}

func (f PendingAudits_StripeIndex_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_StripeIndex_Field) _Column() string { return "stripe_index" }

type PendingAudits_ShareSize_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func PendingAudits_ShareSize(v int64) PendingAudits_ShareSize_Field {
	return PendingAudits_ShareSize_Field{_set: true, _value: v}
}

func (f PendingAudits_ShareSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_ShareSize_Field) _Column() string { return "share_size" }

type PendingAudits_ExpectedShareHash_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func PendingAudits_ExpectedShareHash(v []byte) PendingAudits_ExpectedShareHash_Field {
	return PendingAudits_ExpectedShareHash_Field{_set: true, _value: v}
}

func (f PendingAudits_ExpectedShareHash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_ExpectedShareHash_Field) _Column() string { return "expected_share_hash" }

type PendingAudits_ReverifyCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func PendingAudits_ReverifyCount(v int64) PendingAudits_ReverifyCount_Field {
	return PendingAudits_ReverifyCount_Field{_set: true, _value: v}
}

func (f PendingAudits_ReverifyCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_ReverifyCount_Field) _Column() string { return "reverify_count" }

type PendingAudits_Path_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func PendingAudits_Path(v []byte) PendingAudits_Path_Field {
	return PendingAudits_Path_Field{_set: true, _value: v}
}

func (f PendingAudits_Path_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PendingAudits_Path_Field) _Column() string { return "path" }

type Project struct {
	Id          []byte
	Name        string
	Description string
	UsageLimit  int64
	PartnerId   []byte
	CreatedAt   time.Time
}

func (Project) _Table() string { return "projects" }

type Project_Create_Fields struct {
	PartnerId Project_PartnerId_Field
}

type Project_Update_Fields struct {
	Description Project_Description_Field
	UsageLimit  Project_UsageLimit_Field
}

type Project_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Project_Id(v []byte) Project_Id_Field {
	return Project_Id_Field{_set: true, _value: v}
}

func (f Project_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Id_Field) _Column() string { return "id" }

type Project_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Project_Name(v string) Project_Name_Field {
	return Project_Name_Field{_set: true, _value: v}
}

func (f Project_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Name_Field) _Column() string { return "name" }

type Project_Description_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Project_Description(v string) Project_Description_Field {
	return Project_Description_Field{_set: true, _value: v}
}

func (f Project_Description_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Description_Field) _Column() string { return "description" }

type Project_UsageLimit_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Project_UsageLimit(v int64) Project_UsageLimit_Field {
	return Project_UsageLimit_Field{_set: true, _value: v}
}

func (f Project_UsageLimit_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_UsageLimit_Field) _Column() string { return "usage_limit" }

type Project_PartnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Project_PartnerId(v []byte) Project_PartnerId_Field {
	return Project_PartnerId_Field{_set: true, _value: v}
}

func Project_PartnerId_Raw(v []byte) Project_PartnerId_Field {
	if v == nil {
		return Project_PartnerId_Null()
	}
	return Project_PartnerId(v)
}

func Project_PartnerId_Null() Project_PartnerId_Field {
	return Project_PartnerId_Field{_set: true, _null: true}
}

func (f Project_PartnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Project_PartnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_PartnerId_Field) _Column() string { return "partner_id" }

type Project_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Project_CreatedAt(v time.Time) Project_CreatedAt_Field {
	return Project_CreatedAt_Field{_set: true, _value: v}
}

func (f Project_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_CreatedAt_Field) _Column() string { return "created_at" }

type RegistrationToken struct {
	Secret       []byte
	OwnerId      []byte
	ProjectLimit int
	CreatedAt    time.Time
}

func (RegistrationToken) _Table() string { return "registration_tokens" }

type RegistrationToken_Create_Fields struct {
	OwnerId RegistrationToken_OwnerId_Field
}

type RegistrationToken_Update_Fields struct {
	OwnerId RegistrationToken_OwnerId_Field
}

type RegistrationToken_Secret_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func RegistrationToken_Secret(v []byte) RegistrationToken_Secret_Field {
	return RegistrationToken_Secret_Field{_set: true, _value: v}
}

func (f RegistrationToken_Secret_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_Secret_Field) _Column() string { return "secret" }

type RegistrationToken_OwnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func RegistrationToken_OwnerId(v []byte) RegistrationToken_OwnerId_Field {
	return RegistrationToken_OwnerId_Field{_set: true, _value: v}
}

func RegistrationToken_OwnerId_Raw(v []byte) RegistrationToken_OwnerId_Field {
	if v == nil {
		return RegistrationToken_OwnerId_Null()
	}
	return RegistrationToken_OwnerId(v)
}

func RegistrationToken_OwnerId_Null() RegistrationToken_OwnerId_Field {
	return RegistrationToken_OwnerId_Field{_set: true, _null: true}
}

func (f RegistrationToken_OwnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f RegistrationToken_OwnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_OwnerId_Field) _Column() string { return "owner_id" }

type RegistrationToken_ProjectLimit_Field struct {
	_set   bool
	_null  bool
	_value int
}

func RegistrationToken_ProjectLimit(v int) RegistrationToken_ProjectLimit_Field {
	return RegistrationToken_ProjectLimit_Field{_set: true, _value: v}
}

func (f RegistrationToken_ProjectLimit_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_ProjectLimit_Field) _Column() string { return "project_limit" }

type RegistrationToken_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func RegistrationToken_CreatedAt(v time.Time) RegistrationToken_CreatedAt_Field {
	return RegistrationToken_CreatedAt_Field{_set: true, _value: v}
}

func (f RegistrationToken_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_CreatedAt_Field) _Column() string { return "created_at" }

type ResetPasswordToken struct {
	Secret    []byte
	OwnerId   []byte
	CreatedAt time.Time
}

func (ResetPasswordToken) _Table() string { return "reset_password_tokens" }

type ResetPasswordToken_Update_Fields struct {
	OwnerId ResetPasswordToken_OwnerId_Field
}

type ResetPasswordToken_Secret_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ResetPasswordToken_Secret(v []byte) ResetPasswordToken_Secret_Field {
	return ResetPasswordToken_Secret_Field{_set: true, _value: v}
}

func (f ResetPasswordToken_Secret_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ResetPasswordToken_Secret_Field) _Column() string { return "secret" }

type ResetPasswordToken_OwnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ResetPasswordToken_OwnerId(v []byte) ResetPasswordToken_OwnerId_Field {
	return ResetPasswordToken_OwnerId_Field{_set: true, _value: v}
}

func (f ResetPasswordToken_OwnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ResetPasswordToken_OwnerId_Field) _Column() string { return "owner_id" }

type ResetPasswordToken_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ResetPasswordToken_CreatedAt(v time.Time) ResetPasswordToken_CreatedAt_Field {
	return ResetPasswordToken_CreatedAt_Field{_set: true, _value: v}
}

func (f ResetPasswordToken_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ResetPasswordToken_CreatedAt_Field) _Column() string { return "created_at" }

type SerialNumber struct {
	Id           int
	SerialNumber []byte
	BucketId     []byte
	ExpiresAt    time.Time
}

func (SerialNumber) _Table() string { return "serial_numbers" }

type SerialNumber_Update_Fields struct {
}

type SerialNumber_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func SerialNumber_Id(v int) SerialNumber_Id_Field {
	return SerialNumber_Id_Field{_set: true, _value: v}
}

func (f SerialNumber_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_Id_Field) _Column() string { return "id" }

type SerialNumber_SerialNumber_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func SerialNumber_SerialNumber(v []byte) SerialNumber_SerialNumber_Field {
	return SerialNumber_SerialNumber_Field{_set: true, _value: v}
}

func (f SerialNumber_SerialNumber_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_SerialNumber_Field) _Column() string { return "serial_number" }

type SerialNumber_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func SerialNumber_BucketId(v []byte) SerialNumber_BucketId_Field {
	return SerialNumber_BucketId_Field{_set: true, _value: v}
}

func (f SerialNumber_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_BucketId_Field) _Column() string { return "bucket_id" }

type SerialNumber_ExpiresAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func SerialNumber_ExpiresAt(v time.Time) SerialNumber_ExpiresAt_Field {
	v = toUTC(v)
	return SerialNumber_ExpiresAt_Field{_set: true, _value: v}
}

func (f SerialNumber_ExpiresAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_ExpiresAt_Field) _Column() string { return "expires_at" }

type StoragenodeBandwidthRollup struct {
	StoragenodeId   []byte
	IntervalStart   time.Time
	IntervalSeconds uint
	Action          uint
	Allocated       uint64
	Settled         uint64
}

func (StoragenodeBandwidthRollup) _Table() string { return "storagenode_bandwidth_rollups" }

type StoragenodeBandwidthRollup_Update_Fields struct {
	Allocated StoragenodeBandwidthRollup_Allocated_Field
	Settled   StoragenodeBandwidthRollup_Settled_Field
}

type StoragenodeBandwidthRollup_StoragenodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func StoragenodeBandwidthRollup_StoragenodeId(v []byte) StoragenodeBandwidthRollup_StoragenodeId_Field {
	return StoragenodeBandwidthRollup_StoragenodeId_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_StoragenodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_StoragenodeId_Field) _Column() string { return "storagenode_id" }

type StoragenodeBandwidthRollup_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func StoragenodeBandwidthRollup_IntervalStart(v time.Time) StoragenodeBandwidthRollup_IntervalStart_Field {
	v = toUTC(v)
	return StoragenodeBandwidthRollup_IntervalStart_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_IntervalStart_Field) _Column() string { return "interval_start" }

type StoragenodeBandwidthRollup_IntervalSeconds_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func StoragenodeBandwidthRollup_IntervalSeconds(v uint) StoragenodeBandwidthRollup_IntervalSeconds_Field {
	return StoragenodeBandwidthRollup_IntervalSeconds_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_IntervalSeconds_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_IntervalSeconds_Field) _Column() string { return "interval_seconds" }

type StoragenodeBandwidthRollup_Action_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func StoragenodeBandwidthRollup_Action(v uint) StoragenodeBandwidthRollup_Action_Field {
	return StoragenodeBandwidthRollup_Action_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Action_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Action_Field) _Column() string { return "action" }

type StoragenodeBandwidthRollup_Allocated_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func StoragenodeBandwidthRollup_Allocated(v uint64) StoragenodeBandwidthRollup_Allocated_Field {
	return StoragenodeBandwidthRollup_Allocated_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Allocated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Allocated_Field) _Column() string { return "allocated" }

type StoragenodeBandwidthRollup_Settled_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func StoragenodeBandwidthRollup_Settled(v uint64) StoragenodeBandwidthRollup_Settled_Field {
	return StoragenodeBandwidthRollup_Settled_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Settled_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Settled_Field) _Column() string { return "settled" }

type StoragenodeStorageTally struct {
	Id              int64
	NodeId          []byte
	IntervalEndTime time.Time
	DataTotal       float64
}

func (StoragenodeStorageTally) _Table() string { return "storagenode_storage_tallies" }

type StoragenodeStorageTally_Update_Fields struct {
}

type StoragenodeStorageTally_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func StoragenodeStorageTally_Id(v int64) StoragenodeStorageTally_Id_Field {
	return StoragenodeStorageTally_Id_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_Id_Field) _Column() string { return "id" }

type StoragenodeStorageTally_NodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func StoragenodeStorageTally_NodeId(v []byte) StoragenodeStorageTally_NodeId_Field {
	return StoragenodeStorageTally_NodeId_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_NodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_NodeId_Field) _Column() string { return "node_id" }

type StoragenodeStorageTally_IntervalEndTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func StoragenodeStorageTally_IntervalEndTime(v time.Time) StoragenodeStorageTally_IntervalEndTime_Field {
	return StoragenodeStorageTally_IntervalEndTime_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_IntervalEndTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_IntervalEndTime_Field) _Column() string { return "interval_end_time" }

type StoragenodeStorageTally_DataTotal_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func StoragenodeStorageTally_DataTotal(v float64) StoragenodeStorageTally_DataTotal_Field {
	return StoragenodeStorageTally_DataTotal_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_DataTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_DataTotal_Field) _Column() string { return "data_total" }

type User struct {
	Id           []byte
	Email        string
	FullName     string
	ShortName    *string
	PasswordHash []byte
	Status       int
	PartnerId    []byte
	CreatedAt    time.Time
}

func (User) _Table() string { return "users" }

type User_Create_Fields struct {
	ShortName User_ShortName_Field
	PartnerId User_PartnerId_Field
}

type User_Update_Fields struct {
	Email        User_Email_Field
	FullName     User_FullName_Field
	ShortName    User_ShortName_Field
	PasswordHash User_PasswordHash_Field
	Status       User_Status_Field
}

type User_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func User_Id(v []byte) User_Id_Field {
	return User_Id_Field{_set: true, _value: v}
}

func (f User_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Id_Field) _Column() string { return "id" }

type User_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_Email(v string) User_Email_Field {
	return User_Email_Field{_set: true, _value: v}
}

func (f User_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Email_Field) _Column() string { return "email" }

type User_FullName_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_FullName(v string) User_FullName_Field {
	return User_FullName_Field{_set: true, _value: v}
}

func (f User_FullName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_FullName_Field) _Column() string { return "full_name" }

type User_ShortName_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func User_ShortName(v string) User_ShortName_Field {
	return User_ShortName_Field{_set: true, _value: &v}
}

func User_ShortName_Raw(v *string) User_ShortName_Field {
	if v == nil {
		return User_ShortName_Null()
	}
	return User_ShortName(*v)
}

func User_ShortName_Null() User_ShortName_Field {
	return User_ShortName_Field{_set: true, _null: true}
}

func (f User_ShortName_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f User_ShortName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_ShortName_Field) _Column() string { return "short_name" }

type User_PasswordHash_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func User_PasswordHash(v []byte) User_PasswordHash_Field {
	return User_PasswordHash_Field{_set: true, _value: v}
}

func (f User_PasswordHash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_PasswordHash_Field) _Column() string { return "password_hash" }

type User_Status_Field struct {
	_set   bool
	_null  bool
	_value int
}

func User_Status(v int) User_Status_Field {
	return User_Status_Field{_set: true, _value: v}
}

func (f User_Status_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Status_Field) _Column() string { return "status" }

type User_PartnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func User_PartnerId(v []byte) User_PartnerId_Field {
	return User_PartnerId_Field{_set: true, _value: v}
}

func User_PartnerId_Raw(v []byte) User_PartnerId_Field {
	if v == nil {
		return User_PartnerId_Null()
	}
	return User_PartnerId(v)
}

func User_PartnerId_Null() User_PartnerId_Field {
	return User_PartnerId_Field{_set: true, _null: true}
}

func (f User_PartnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f User_PartnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_PartnerId_Field) _Column() string { return "partner_id" }

type User_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func User_CreatedAt(v time.Time) User_CreatedAt_Field {
	return User_CreatedAt_Field{_set: true, _value: v}
}

func (f User_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_CreatedAt_Field) _Column() string { return "created_at" }

type ValueAttribution struct {
	ProjectId   []byte
	BucketName  []byte
	PartnerId   []byte
	LastUpdated time.Time
}

func (ValueAttribution) _Table() string { return "value_attributions" }

type ValueAttribution_Update_Fields struct {
}

type ValueAttribution_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ValueAttribution_ProjectId(v []byte) ValueAttribution_ProjectId_Field {
	return ValueAttribution_ProjectId_Field{_set: true, _value: v}
}

func (f ValueAttribution_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ValueAttribution_ProjectId_Field) _Column() string { return "project_id" }

type ValueAttribution_BucketName_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ValueAttribution_BucketName(v []byte) ValueAttribution_BucketName_Field {
	return ValueAttribution_BucketName_Field{_set: true, _value: v}
}

func (f ValueAttribution_BucketName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ValueAttribution_BucketName_Field) _Column() string { return "bucket_name" }

type ValueAttribution_PartnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ValueAttribution_PartnerId(v []byte) ValueAttribution_PartnerId_Field {
	return ValueAttribution_PartnerId_Field{_set: true, _value: v}
}

func (f ValueAttribution_PartnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ValueAttribution_PartnerId_Field) _Column() string { return "partner_id" }

type ValueAttribution_LastUpdated_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ValueAttribution_LastUpdated(v time.Time) ValueAttribution_LastUpdated_Field {
	v = toUTC(v)
	return ValueAttribution_LastUpdated_Field{_set: true, _value: v}
}

func (f ValueAttribution_LastUpdated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ValueAttribution_LastUpdated_Field) _Column() string { return "last_updated" }

type ApiKey struct {
	Id        []byte
	ProjectId []byte
	Head      []byte
	Name      string
	Secret    []byte
	PartnerId []byte
	CreatedAt time.Time
}

func (ApiKey) _Table() string { return "api_keys" }

type ApiKey_Create_Fields struct {
	PartnerId ApiKey_PartnerId_Field
}

type ApiKey_Update_Fields struct {
	Name ApiKey_Name_Field
}

type ApiKey_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_Id(v []byte) ApiKey_Id_Field {
	return ApiKey_Id_Field{_set: true, _value: v}
}

func (f ApiKey_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Id_Field) _Column() string { return "id" }

type ApiKey_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_ProjectId(v []byte) ApiKey_ProjectId_Field {
	return ApiKey_ProjectId_Field{_set: true, _value: v}
}

func (f ApiKey_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_ProjectId_Field) _Column() string { return "project_id" }

type ApiKey_Head_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_Head(v []byte) ApiKey_Head_Field {
	return ApiKey_Head_Field{_set: true, _value: v}
}

func (f ApiKey_Head_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Head_Field) _Column() string { return "head" }

type ApiKey_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func ApiKey_Name(v string) ApiKey_Name_Field {
	return ApiKey_Name_Field{_set: true, _value: v}
}

func (f ApiKey_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Name_Field) _Column() string { return "name" }

type ApiKey_Secret_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_Secret(v []byte) ApiKey_Secret_Field {
	return ApiKey_Secret_Field{_set: true, _value: v}
}

func (f ApiKey_Secret_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Secret_Field) _Column() string { return "secret" }

type ApiKey_PartnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_PartnerId(v []byte) ApiKey_PartnerId_Field {
	return ApiKey_PartnerId_Field{_set: true, _value: v}
}

func ApiKey_PartnerId_Raw(v []byte) ApiKey_PartnerId_Field {
	if v == nil {
		return ApiKey_PartnerId_Null()
	}
	return ApiKey_PartnerId(v)
}

func ApiKey_PartnerId_Null() ApiKey_PartnerId_Field {
	return ApiKey_PartnerId_Field{_set: true, _null: true}
}

func (f ApiKey_PartnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f ApiKey_PartnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_PartnerId_Field) _Column() string { return "partner_id" }

type ApiKey_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ApiKey_CreatedAt(v time.Time) ApiKey_CreatedAt_Field {
	return ApiKey_CreatedAt_Field{_set: true, _value: v}
}

func (f ApiKey_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_CreatedAt_Field) _Column() string { return "created_at" }

type BucketMetainfo struct {
	Id                              []byte
	ProjectId                       []byte
	Name                            []byte
	PartnerId                       []byte
	PathCipher                      int
	CreatedAt                       time.Time
	DefaultSegmentSize              int
	DefaultEncryptionCipherSuite    int
	DefaultEncryptionBlockSize      int
	DefaultRedundancyAlgorithm      int
	DefaultRedundancyShareSize      int
	DefaultRedundancyRequiredShares int
	DefaultRedundancyRepairShares   int
	DefaultRedundancyOptimalShares  int
	DefaultRedundancyTotalShares    int
}

func (BucketMetainfo) _Table() string { return "bucket_metainfos" }

type BucketMetainfo_Create_Fields struct {
	PartnerId BucketMetainfo_PartnerId_Field
}

type BucketMetainfo_Update_Fields struct {
	PartnerId                       BucketMetainfo_PartnerId_Field
	DefaultSegmentSize              BucketMetainfo_DefaultSegmentSize_Field
	DefaultEncryptionCipherSuite    BucketMetainfo_DefaultEncryptionCipherSuite_Field
	DefaultEncryptionBlockSize      BucketMetainfo_DefaultEncryptionBlockSize_Field
	DefaultRedundancyAlgorithm      BucketMetainfo_DefaultRedundancyAlgorithm_Field
	DefaultRedundancyShareSize      BucketMetainfo_DefaultRedundancyShareSize_Field
	DefaultRedundancyRequiredShares BucketMetainfo_DefaultRedundancyRequiredShares_Field
	DefaultRedundancyRepairShares   BucketMetainfo_DefaultRedundancyRepairShares_Field
	DefaultRedundancyOptimalShares  BucketMetainfo_DefaultRedundancyOptimalShares_Field
	DefaultRedundancyTotalShares    BucketMetainfo_DefaultRedundancyTotalShares_Field
}

type BucketMetainfo_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketMetainfo_Id(v []byte) BucketMetainfo_Id_Field {
	return BucketMetainfo_Id_Field{_set: true, _value: v}
}

func (f BucketMetainfo_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_Id_Field) _Column() string { return "id" }

type BucketMetainfo_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketMetainfo_ProjectId(v []byte) BucketMetainfo_ProjectId_Field {
	return BucketMetainfo_ProjectId_Field{_set: true, _value: v}
}

func (f BucketMetainfo_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_ProjectId_Field) _Column() string { return "project_id" }

type BucketMetainfo_Name_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketMetainfo_Name(v []byte) BucketMetainfo_Name_Field {
	return BucketMetainfo_Name_Field{_set: true, _value: v}
}

func (f BucketMetainfo_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_Name_Field) _Column() string { return "name" }

type BucketMetainfo_PartnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketMetainfo_PartnerId(v []byte) BucketMetainfo_PartnerId_Field {
	return BucketMetainfo_PartnerId_Field{_set: true, _value: v}
}

func BucketMetainfo_PartnerId_Raw(v []byte) BucketMetainfo_PartnerId_Field {
	if v == nil {
		return BucketMetainfo_PartnerId_Null()
	}
	return BucketMetainfo_PartnerId(v)
}

func BucketMetainfo_PartnerId_Null() BucketMetainfo_PartnerId_Field {
	return BucketMetainfo_PartnerId_Field{_set: true, _null: true}
}

func (f BucketMetainfo_PartnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f BucketMetainfo_PartnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_PartnerId_Field) _Column() string { return "partner_id" }

type BucketMetainfo_PathCipher_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_PathCipher(v int) BucketMetainfo_PathCipher_Field {
	return BucketMetainfo_PathCipher_Field{_set: true, _value: v}
}

func (f BucketMetainfo_PathCipher_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_PathCipher_Field) _Column() string { return "path_cipher" }

type BucketMetainfo_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketMetainfo_CreatedAt(v time.Time) BucketMetainfo_CreatedAt_Field {
	return BucketMetainfo_CreatedAt_Field{_set: true, _value: v}
}

func (f BucketMetainfo_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_CreatedAt_Field) _Column() string { return "created_at" }

type BucketMetainfo_DefaultSegmentSize_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultSegmentSize(v int) BucketMetainfo_DefaultSegmentSize_Field {
	return BucketMetainfo_DefaultSegmentSize_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultSegmentSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultSegmentSize_Field) _Column() string { return "default_segment_size" }

type BucketMetainfo_DefaultEncryptionCipherSuite_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultEncryptionCipherSuite(v int) BucketMetainfo_DefaultEncryptionCipherSuite_Field {
	return BucketMetainfo_DefaultEncryptionCipherSuite_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultEncryptionCipherSuite_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultEncryptionCipherSuite_Field) _Column() string {
	return "default_encryption_cipher_suite"
}

type BucketMetainfo_DefaultEncryptionBlockSize_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultEncryptionBlockSize(v int) BucketMetainfo_DefaultEncryptionBlockSize_Field {
	return BucketMetainfo_DefaultEncryptionBlockSize_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultEncryptionBlockSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultEncryptionBlockSize_Field) _Column() string {
	return "default_encryption_block_size"
}

type BucketMetainfo_DefaultRedundancyAlgorithm_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyAlgorithm(v int) BucketMetainfo_DefaultRedundancyAlgorithm_Field {
	return BucketMetainfo_DefaultRedundancyAlgorithm_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyAlgorithm_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyAlgorithm_Field) _Column() string {
	return "default_redundancy_algorithm"
}

type BucketMetainfo_DefaultRedundancyShareSize_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyShareSize(v int) BucketMetainfo_DefaultRedundancyShareSize_Field {
	return BucketMetainfo_DefaultRedundancyShareSize_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyShareSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyShareSize_Field) _Column() string {
	return "default_redundancy_share_size"
}

type BucketMetainfo_DefaultRedundancyRequiredShares_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyRequiredShares(v int) BucketMetainfo_DefaultRedundancyRequiredShares_Field {
	return BucketMetainfo_DefaultRedundancyRequiredShares_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyRequiredShares_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyRequiredShares_Field) _Column() string {
	return "default_redundancy_required_shares"
}

type BucketMetainfo_DefaultRedundancyRepairShares_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyRepairShares(v int) BucketMetainfo_DefaultRedundancyRepairShares_Field {
	return BucketMetainfo_DefaultRedundancyRepairShares_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyRepairShares_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyRepairShares_Field) _Column() string {
	return "default_redundancy_repair_shares"
}

type BucketMetainfo_DefaultRedundancyOptimalShares_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyOptimalShares(v int) BucketMetainfo_DefaultRedundancyOptimalShares_Field {
	return BucketMetainfo_DefaultRedundancyOptimalShares_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyOptimalShares_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyOptimalShares_Field) _Column() string {
	return "default_redundancy_optimal_shares"
}

type BucketMetainfo_DefaultRedundancyTotalShares_Field struct {
	_set   bool
	_null  bool
	_value int
}

func BucketMetainfo_DefaultRedundancyTotalShares(v int) BucketMetainfo_DefaultRedundancyTotalShares_Field {
	return BucketMetainfo_DefaultRedundancyTotalShares_Field{_set: true, _value: v}
}

func (f BucketMetainfo_DefaultRedundancyTotalShares_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketMetainfo_DefaultRedundancyTotalShares_Field) _Column() string {
	return "default_redundancy_total_shares"
}

type ProjectInvoiceStamp struct {
	ProjectId []byte
	InvoiceId []byte
	StartDate time.Time
	EndDate   time.Time
	CreatedAt time.Time
}

func (ProjectInvoiceStamp) _Table() string { return "project_invoice_stamps" }

type ProjectInvoiceStamp_Update_Fields struct {
}

type ProjectInvoiceStamp_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectInvoiceStamp_ProjectId(v []byte) ProjectInvoiceStamp_ProjectId_Field {
	return ProjectInvoiceStamp_ProjectId_Field{_set: true, _value: v}
}

func (f ProjectInvoiceStamp_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectInvoiceStamp_ProjectId_Field) _Column() string { return "project_id" }

type ProjectInvoiceStamp_InvoiceId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectInvoiceStamp_InvoiceId(v []byte) ProjectInvoiceStamp_InvoiceId_Field {
	return ProjectInvoiceStamp_InvoiceId_Field{_set: true, _value: v}
}

func (f ProjectInvoiceStamp_InvoiceId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectInvoiceStamp_InvoiceId_Field) _Column() string { return "invoice_id" }

type ProjectInvoiceStamp_StartDate_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectInvoiceStamp_StartDate(v time.Time) ProjectInvoiceStamp_StartDate_Field {
	return ProjectInvoiceStamp_StartDate_Field{_set: true, _value: v}
}

func (f ProjectInvoiceStamp_StartDate_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectInvoiceStamp_StartDate_Field) _Column() string { return "start_date" }

type ProjectInvoiceStamp_EndDate_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectInvoiceStamp_EndDate(v time.Time) ProjectInvoiceStamp_EndDate_Field {
	return ProjectInvoiceStamp_EndDate_Field{_set: true, _value: v}
}

func (f ProjectInvoiceStamp_EndDate_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectInvoiceStamp_EndDate_Field) _Column() string { return "end_date" }

type ProjectInvoiceStamp_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectInvoiceStamp_CreatedAt(v time.Time) ProjectInvoiceStamp_CreatedAt_Field {
	return ProjectInvoiceStamp_CreatedAt_Field{_set: true, _value: v}
}

func (f ProjectInvoiceStamp_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectInvoiceStamp_CreatedAt_Field) _Column() string { return "created_at" }

type ProjectMember struct {
	MemberId  []byte
	ProjectId []byte
	CreatedAt time.Time
}

func (ProjectMember) _Table() string { return "project_members" }

type ProjectMember_Update_Fields struct {
}

type ProjectMember_MemberId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectMember_MemberId(v []byte) ProjectMember_MemberId_Field {
	return ProjectMember_MemberId_Field{_set: true, _value: v}
}

func (f ProjectMember_MemberId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_MemberId_Field) _Column() string { return "member_id" }

type ProjectMember_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectMember_ProjectId(v []byte) ProjectMember_ProjectId_Field {
	return ProjectMember_ProjectId_Field{_set: true, _value: v}
}

func (f ProjectMember_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_ProjectId_Field) _Column() string { return "project_id" }

type ProjectMember_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectMember_CreatedAt(v time.Time) ProjectMember_CreatedAt_Field {
	return ProjectMember_CreatedAt_Field{_set: true, _value: v}
}

func (f ProjectMember_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_CreatedAt_Field) _Column() string { return "created_at" }

type UsedSerial struct {
	SerialNumberId int
	StorageNodeId  []byte
}

func (UsedSerial) _Table() string { return "used_serials" }

type UsedSerial_Update_Fields struct {
}

type UsedSerial_SerialNumberId_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UsedSerial_SerialNumberId(v int) UsedSerial_SerialNumberId_Field {
	return UsedSerial_SerialNumberId_Field{_set: true, _value: v}
}

func (f UsedSerial_SerialNumberId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UsedSerial_SerialNumberId_Field) _Column() string { return "serial_number_id" }

type UsedSerial_StorageNodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UsedSerial_StorageNodeId(v []byte) UsedSerial_StorageNodeId_Field {
	return UsedSerial_StorageNodeId_Field{_set: true, _value: v}
}

func (f UsedSerial_StorageNodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UsedSerial_StorageNodeId_Field) _Column() string { return "storage_node_id" }

type UserCredit struct {
	Id                   int
	UserId               []byte
	OfferId              int
	ReferredBy           []byte
	CreditsEarnedInCents int
	CreditsUsedInCents   int
	ExpiresAt            time.Time
	CreatedAt            time.Time
}

func (UserCredit) _Table() string { return "user_credits" }

type UserCredit_Create_Fields struct {
	ReferredBy UserCredit_ReferredBy_Field
}

type UserCredit_Update_Fields struct {
	CreditsUsedInCents UserCredit_CreditsUsedInCents_Field
	ExpiresAt          UserCredit_ExpiresAt_Field
}

type UserCredit_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UserCredit_Id(v int) UserCredit_Id_Field {
	return UserCredit_Id_Field{_set: true, _value: v}
}

func (f UserCredit_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_Id_Field) _Column() string { return "id" }

type UserCredit_UserId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UserCredit_UserId(v []byte) UserCredit_UserId_Field {
	return UserCredit_UserId_Field{_set: true, _value: v}
}

func (f UserCredit_UserId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_UserId_Field) _Column() string { return "user_id" }

type UserCredit_OfferId_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UserCredit_OfferId(v int) UserCredit_OfferId_Field {
	return UserCredit_OfferId_Field{_set: true, _value: v}
}

func (f UserCredit_OfferId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_OfferId_Field) _Column() string { return "offer_id" }

type UserCredit_ReferredBy_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UserCredit_ReferredBy(v []byte) UserCredit_ReferredBy_Field {
	return UserCredit_ReferredBy_Field{_set: true, _value: v}
}

func UserCredit_ReferredBy_Raw(v []byte) UserCredit_ReferredBy_Field {
	if v == nil {
		return UserCredit_ReferredBy_Null()
	}
	return UserCredit_ReferredBy(v)
}

func UserCredit_ReferredBy_Null() UserCredit_ReferredBy_Field {
	return UserCredit_ReferredBy_Field{_set: true, _null: true}
}

func (f UserCredit_ReferredBy_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f UserCredit_ReferredBy_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_ReferredBy_Field) _Column() string { return "referred_by" }

type UserCredit_CreditsEarnedInCents_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UserCredit_CreditsEarnedInCents(v int) UserCredit_CreditsEarnedInCents_Field {
	return UserCredit_CreditsEarnedInCents_Field{_set: true, _value: v}
}

func (f UserCredit_CreditsEarnedInCents_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_CreditsEarnedInCents_Field) _Column() string { return "credits_earned_in_cents" }

type UserCredit_CreditsUsedInCents_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UserCredit_CreditsUsedInCents(v int) UserCredit_CreditsUsedInCents_Field {
	return UserCredit_CreditsUsedInCents_Field{_set: true, _value: v}
}

func (f UserCredit_CreditsUsedInCents_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_CreditsUsedInCents_Field) _Column() string { return "credits_used_in_cents" }

type UserCredit_ExpiresAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func UserCredit_ExpiresAt(v time.Time) UserCredit_ExpiresAt_Field {
	return UserCredit_ExpiresAt_Field{_set: true, _value: v}
}

func (f UserCredit_ExpiresAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_ExpiresAt_Field) _Column() string { return "expires_at" }

type UserCredit_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func UserCredit_CreatedAt(v time.Time) UserCredit_CreatedAt_Field {
	return UserCredit_CreatedAt_Field{_set: true, _value: v}
}

func (f UserCredit_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserCredit_CreatedAt_Field) _Column() string { return "created_at" }

type UserPayment struct {
	UserId     []byte
	CustomerId []byte
	CreatedAt  time.Time
}

func (UserPayment) _Table() string { return "user_payments" }

type UserPayment_Update_Fields struct {
}

type UserPayment_UserId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UserPayment_UserId(v []byte) UserPayment_UserId_Field {
	return UserPayment_UserId_Field{_set: true, _value: v}
}

func (f UserPayment_UserId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserPayment_UserId_Field) _Column() string { return "user_id" }

type UserPayment_CustomerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UserPayment_CustomerId(v []byte) UserPayment_CustomerId_Field {
	return UserPayment_CustomerId_Field{_set: true, _value: v}
}

func (f UserPayment_CustomerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserPayment_CustomerId_Field) _Column() string { return "customer_id" }

type UserPayment_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func UserPayment_CreatedAt(v time.Time) UserPayment_CreatedAt_Field {
	return UserPayment_CreatedAt_Field{_set: true, _value: v}
}

func (f UserPayment_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UserPayment_CreatedAt_Field) _Column() string { return "created_at" }

type ProjectPayment struct {
	Id              []byte
	ProjectId       []byte
	PayerId         []byte
	PaymentMethodId []byte
	IsDefault       bool
	CreatedAt       time.Time
}

func (ProjectPayment) _Table() string { return "project_payments" }

type ProjectPayment_Update_Fields struct {
	IsDefault ProjectPayment_IsDefault_Field
}

type ProjectPayment_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectPayment_Id(v []byte) ProjectPayment_Id_Field {
	return ProjectPayment_Id_Field{_set: true, _value: v}
}

func (f ProjectPayment_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_Id_Field) _Column() string { return "id" }

type ProjectPayment_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectPayment_ProjectId(v []byte) ProjectPayment_ProjectId_Field {
	return ProjectPayment_ProjectId_Field{_set: true, _value: v}
}

func (f ProjectPayment_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_ProjectId_Field) _Column() string { return "project_id" }

type ProjectPayment_PayerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectPayment_PayerId(v []byte) ProjectPayment_PayerId_Field {
	return ProjectPayment_PayerId_Field{_set: true, _value: v}
}

func (f ProjectPayment_PayerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_PayerId_Field) _Column() string { return "payer_id" }

type ProjectPayment_PaymentMethodId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectPayment_PaymentMethodId(v []byte) ProjectPayment_PaymentMethodId_Field {
	return ProjectPayment_PaymentMethodId_Field{_set: true, _value: v}
}

func (f ProjectPayment_PaymentMethodId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_PaymentMethodId_Field) _Column() string { return "payment_method_id" }

type ProjectPayment_IsDefault_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func ProjectPayment_IsDefault(v bool) ProjectPayment_IsDefault_Field {
	return ProjectPayment_IsDefault_Field{_set: true, _value: v}
}

func (f ProjectPayment_IsDefault_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_IsDefault_Field) _Column() string { return "is_default" }

type ProjectPayment_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectPayment_CreatedAt(v time.Time) ProjectPayment_CreatedAt_Field {
	return ProjectPayment_CreatedAt_Field{_set: true, _value: v}
}

func (f ProjectPayment_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectPayment_CreatedAt_Field) _Column() string { return "created_at" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	out := make([]byte, 0, len(sql)+10)

	j := 1
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		if ch != '?' {
			out = append(out, ch)
			continue
		}

		out = append(out, '$')
		out = append(out, strconv.Itoa(j)...)
		j++
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string { return h.SQL.Render() }

//
// end runtime support for building sql statements
//

type Id_LastNet_Address_Protocol_Row struct {
	Id       []byte
	LastNet  string
	Address  string
	Protocol int
}

type Id_Row struct {
	Id []byte
}

type Value_Row struct {
	Value time.Time
}

func (obj *postgresImpl) Create_ValueAttribution(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field,
	value_attribution_partner_id ValueAttribution_PartnerId_Field) (
	value_attribution *ValueAttribution, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__project_id_val := value_attribution_project_id.value()
	__bucket_name_val := value_attribution_bucket_name.value()
	__partner_id_val := value_attribution_partner_id.value()
	__last_updated_val := __now.UTC()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO value_attributions ( project_id, bucket_name, partner_id, last_updated ) VALUES ( ?, ?, ?, ? ) RETURNING value_attributions.project_id, value_attributions.bucket_name, value_attributions.partner_id, value_attributions.last_updated")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __project_id_val, __bucket_name_val, __partner_id_val, __last_updated_val)

	value_attribution = &ValueAttribution{}
	err = obj.driver.QueryRow(__stmt, __project_id_val, __bucket_name_val, __partner_id_val, __last_updated_val).Scan(&value_attribution.ProjectId, &value_attribution.BucketName, &value_attribution.PartnerId, &value_attribution.LastUpdated)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return value_attribution, nil

}

func (obj *postgresImpl) Create_PendingAudits(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	pending_audits_piece_id PendingAudits_PieceId_Field,
	pending_audits_stripe_index PendingAudits_StripeIndex_Field,
	pending_audits_share_size PendingAudits_ShareSize_Field,
	pending_audits_expected_share_hash PendingAudits_ExpectedShareHash_Field,
	pending_audits_reverify_count PendingAudits_ReverifyCount_Field,
	pending_audits_path PendingAudits_Path_Field) (
	pending_audits *PendingAudits, err error) {
	__node_id_val := pending_audits_node_id.value()
	__piece_id_val := pending_audits_piece_id.value()
	__stripe_index_val := pending_audits_stripe_index.value()
	__share_size_val := pending_audits_share_size.value()
	__expected_share_hash_val := pending_audits_expected_share_hash.value()
	__reverify_count_val := pending_audits_reverify_count.value()
	__path_val := pending_audits_path.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO pending_audits ( node_id, piece_id, stripe_index, share_size, expected_share_hash, reverify_count, path ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) RETURNING pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __piece_id_val, __stripe_index_val, __share_size_val, __expected_share_hash_val, __reverify_count_val, __path_val)

	pending_audits = &PendingAudits{}
	err = obj.driver.QueryRow(__stmt, __node_id_val, __piece_id_val, __stripe_index_val, __share_size_val, __expected_share_hash_val, __reverify_count_val, __path_val).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil

}

func (obj *postgresImpl) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	__segmentpath_val := irreparabledb_segmentpath.value()
	__segmentdetail_val := irreparabledb_segmentdetail.value()
	__pieces_lost_count_val := irreparabledb_pieces_lost_count.value()
	__seg_damaged_unix_sec_val := irreparabledb_seg_damaged_unix_sec.value()
	__repair_attempt_count_val := irreparabledb_repair_attempt_count.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO irreparabledbs ( segmentpath, segmentdetail, pieces_lost_count, seg_damaged_unix_sec, repair_attempt_count ) VALUES ( ?, ?, ?, ?, ? ) RETURNING irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *postgresImpl) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	__name_val := accounting_timestamps_name.value()
	__value_val := accounting_timestamps_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_timestamps ( name, value ) VALUES ( ?, ? ) RETURNING accounting_timestamps.name, accounting_timestamps.value")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __value_val)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, __name_val, __value_val).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil

}

func (obj *postgresImpl) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	__node_id_val := accounting_rollup_node_id.value()
	__start_time_val := accounting_rollup_start_time.value()
	__put_total_val := accounting_rollup_put_total.value()
	__get_total_val := accounting_rollup_get_total.value()
	__get_audit_total_val := accounting_rollup_get_audit_total.value()
	__get_repair_total_val := accounting_rollup_get_repair_total.value()
	__put_repair_total_val := accounting_rollup_put_repair_total.value()
	__at_rest_total_val := accounting_rollup_at_rest_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_rollups ( node_id, start_time, put_total, get_total, get_audit_total, get_repair_total, put_repair_total, at_rest_total ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *postgresImpl) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_last_net Node_LastNet_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_major Node_Major_Field,
	node_minor Node_Minor_Field,
	node_patch Node_Patch_Field,
	node_hash Node_Hash_Field,
	node_timestamp Node_Timestamp_Field,
	node_release Node_Release_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field,
	node_contained Node_Contained_Field,
	node_audit_reputation_alpha Node_AuditReputationAlpha_Field,
	node_audit_reputation_beta Node_AuditReputationBeta_Field,
	node_uptime_reputation_alpha Node_UptimeReputationAlpha_Field,
	node_uptime_reputation_beta Node_UptimeReputationBeta_Field,
	optional Node_Create_Fields) (
	node *Node, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := node_id.value()
	__address_val := node_address.value()
	__last_net_val := node_last_net.value()
	__protocol_val := node_protocol.value()
	__type_val := node_type.value()
	__email_val := node_email.value()
	__wallet_val := node_wallet.value()
	__free_bandwidth_val := node_free_bandwidth.value()
	__free_disk_val := node_free_disk.value()
	__major_val := node_major.value()
	__minor_val := node_minor.value()
	__patch_val := node_patch.value()
	__hash_val := node_hash.value()
	__timestamp_val := node_timestamp.value()
	__release_val := node_release.value()
	__latency_90_val := node_latency_90.value()
	__audit_success_count_val := node_audit_success_count.value()
	__total_audit_count_val := node_total_audit_count.value()
	__uptime_success_count_val := node_uptime_success_count.value()
	__total_uptime_count_val := node_total_uptime_count.value()
	__created_at_val := __now
	__updated_at_val := __now
	__last_contact_success_val := node_last_contact_success.value()
	__last_contact_failure_val := node_last_contact_failure.value()
	__contained_val := node_contained.value()
	__disqualified_val := optional.Disqualified.value()
	__audit_reputation_alpha_val := node_audit_reputation_alpha.value()
	__audit_reputation_beta_val := node_audit_reputation_beta.value()
	__uptime_reputation_alpha_val := node_uptime_reputation_alpha.value()
	__uptime_reputation_beta_val := node_uptime_reputation_beta.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO nodes ( id, address, last_net, protocol, type, email, wallet, free_bandwidth, free_disk, major, minor, patch, hash, timestamp, release, latency_90, audit_success_count, total_audit_count, uptime_success_count, total_uptime_count, created_at, updated_at, last_contact_success, last_contact_failure, contained, disqualified, audit_reputation_alpha, audit_reputation_beta, uptime_reputation_alpha, uptime_reputation_beta ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __address_val, __last_net_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __major_val, __minor_val, __patch_val, __hash_val, __timestamp_val, __release_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __uptime_success_count_val, __total_uptime_count_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val, __contained_val, __disqualified_val, __audit_reputation_alpha_val, __audit_reputation_beta_val, __uptime_reputation_alpha_val, __uptime_reputation_beta_val)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __id_val, __address_val, __last_net_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __major_val, __minor_val, __patch_val, __hash_val, __timestamp_val, __release_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __uptime_success_count_val, __total_uptime_count_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val, __contained_val, __disqualified_val, __audit_reputation_alpha_val, __audit_reputation_beta_val, __uptime_reputation_alpha_val, __uptime_reputation_beta_val).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *postgresImpl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_full_name User_FullName_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__email_val := user_email.value()
	__full_name_val := user_full_name.value()
	__short_name_val := optional.ShortName.value()
	__password_hash_val := user_password_hash.value()
	__status_val := int(0)
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, email, full_name, short_name, password_hash, status, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __email_val, __full_name_val, __short_name_val, __password_hash_val, __status_val, __partner_id_val, __created_at_val)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __id_val, __email_val, __full_name_val, __short_name_val, __password_hash_val, __status_val, __partner_id_val, __created_at_val).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Create_UserPayment(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field,
	user_payment_customer_id UserPayment_CustomerId_Field) (
	user_payment *UserPayment, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__user_id_val := user_payment_user_id.value()
	__customer_id_val := user_payment_customer_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO user_payments ( user_id, customer_id, created_at ) VALUES ( ?, ?, ? ) RETURNING user_payments.user_id, user_payments.customer_id, user_payments.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __user_id_val, __customer_id_val, __created_at_val)

	user_payment = &UserPayment{}
	err = obj.driver.QueryRow(__stmt, __user_id_val, __customer_id_val, __created_at_val).Scan(&user_payment.UserId, &user_payment.CustomerId, &user_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_payment, nil

}

func (obj *postgresImpl) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field,
	project_usage_limit Project_UsageLimit_Field,
	optional Project_Create_Fields) (
	project *Project, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_id.value()
	__name_val := project_name.value()
	__description_val := project_description.value()
	__usage_limit_val := project_usage_limit.value()
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO projects ( id, name, description, usage_limit, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ? ) RETURNING projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __name_val, __description_val, __usage_limit_val, __partner_id_val, __created_at_val)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __id_val, __name_val, __description_val, __usage_limit_val, __partner_id_val, __created_at_val).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *postgresImpl) Create_ProjectPayment(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	project_payment_project_id ProjectPayment_ProjectId_Field,
	project_payment_payer_id ProjectPayment_PayerId_Field,
	project_payment_payment_method_id ProjectPayment_PaymentMethodId_Field,
	project_payment_is_default ProjectPayment_IsDefault_Field) (
	project_payment *ProjectPayment, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_payment_id.value()
	__project_id_val := project_payment_project_id.value()
	__payer_id_val := project_payment_payer_id.value()
	__payment_method_id_val := project_payment_payment_method_id.value()
	__is_default_val := project_payment_is_default.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_payments ( id, project_id, payer_id, payment_method_id, is_default, created_at ) VALUES ( ?, ?, ?, ?, ?, ? ) RETURNING project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __payer_id_val, __payment_method_id_val, __is_default_val, __created_at_val)

	project_payment = &ProjectPayment{}
	err = obj.driver.QueryRow(__stmt, __id_val, __project_id_val, __payer_id_val, __payment_method_id_val, __is_default_val, __created_at_val).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil

}

func (obj *postgresImpl) Create_ProjectInvoiceStamp(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_invoice_id ProjectInvoiceStamp_InvoiceId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field,
	project_invoice_stamp_end_date ProjectInvoiceStamp_EndDate_Field,
	project_invoice_stamp_created_at ProjectInvoiceStamp_CreatedAt_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {
	__project_id_val := project_invoice_stamp_project_id.value()
	__invoice_id_val := project_invoice_stamp_invoice_id.value()
	__start_date_val := project_invoice_stamp_start_date.value()
	__end_date_val := project_invoice_stamp_end_date.value()
	__created_at_val := project_invoice_stamp_created_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_invoice_stamps ( project_id, invoice_id, start_date, end_date, created_at ) VALUES ( ?, ?, ?, ?, ? ) RETURNING project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __project_id_val, __invoice_id_val, __start_date_val, __end_date_val, __created_at_val)

	project_invoice_stamp = &ProjectInvoiceStamp{}
	err = obj.driver.QueryRow(__stmt, __project_id_val, __invoice_id_val, __start_date_val, __end_date_val, __created_at_val).Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_invoice_stamp, nil

}

func (obj *postgresImpl) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__member_id_val := project_member_member_id.value()
	__project_id_val := project_member_project_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_members ( member_id, project_id, created_at ) VALUES ( ?, ?, ? ) RETURNING project_members.member_id, project_members.project_id, project_members.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __member_id_val, __project_id_val, __created_at_val)

	project_member = &ProjectMember{}
	err = obj.driver.QueryRow(__stmt, __member_id_val, __project_id_val, __created_at_val).Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_member, nil

}

func (obj *postgresImpl) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_head ApiKey_Head_Field,
	api_key_name ApiKey_Name_Field,
	api_key_secret ApiKey_Secret_Field,
	optional ApiKey_Create_Fields) (
	api_key *ApiKey, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := api_key_id.value()
	__project_id_val := api_key_project_id.value()
	__head_val := api_key_head.value()
	__name_val := api_key_name.value()
	__secret_val := api_key_secret.value()
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO api_keys ( id, project_id, head, name, secret, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) RETURNING api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __head_val, __name_val, __secret_val, __partner_id_val, __created_at_val)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __id_val, __project_id_val, __head_val, __name_val, __secret_val, __partner_id_val, __created_at_val).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	__id_val := bucket_usage_id.value()
	__bucket_id_val := bucket_usage_bucket_id.value()
	__rollup_end_time_val := bucket_usage_rollup_end_time.value()
	__remote_stored_data_val := bucket_usage_remote_stored_data.value()
	__inline_stored_data_val := bucket_usage_inline_stored_data.value()
	__remote_segments_val := bucket_usage_remote_segments.value()
	__inline_segments_val := bucket_usage_inline_segments.value()
	__objects_val := bucket_usage_objects.value()
	__metadata_size_val := bucket_usage_metadata_size.value()
	__repair_egress_val := bucket_usage_repair_egress.value()
	__get_egress_val := bucket_usage_get_egress.value()
	__audit_egress_val := bucket_usage_audit_egress.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_usages ( id, bucket_id, rollup_end_time, remote_stored_data, inline_stored_data, remote_segments, inline_segments, objects, metadata_size, repair_egress, get_egress, audit_egress ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *postgresImpl) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	__serial_number_val := serial_number_serial_number.value()
	__bucket_id_val := serial_number_bucket_id.value()
	__expires_at_val := serial_number_expires_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO serial_numbers ( serial_number, bucket_id, expires_at ) VALUES ( ?, ?, ? ) RETURNING serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)

	serial_number = &SerialNumber{}
	err = obj.driver.QueryRow(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val).Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return serial_number, nil

}

func (obj *postgresImpl) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	__serial_number_id_val := used_serial_serial_number_id.value()
	__storage_node_id_val := used_serial_storage_node_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO used_serials ( serial_number_id, storage_node_id ) VALUES ( ?, ? ) RETURNING used_serials.serial_number_id, used_serials.storage_node_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_id_val, __storage_node_id_val)

	used_serial = &UsedSerial{}
	err = obj.driver.QueryRow(__stmt, __serial_number_id_val, __storage_node_id_val).Scan(&used_serial.SerialNumberId, &used_serial.StorageNodeId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return used_serial, nil

}

func (obj *postgresImpl) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	__bucket_name_val := bucket_storage_tally_bucket_name.value()
	__project_id_val := bucket_storage_tally_project_id.value()
	__interval_start_val := bucket_storage_tally_interval_start.value()
	__inline_val := bucket_storage_tally_inline.value()
	__remote_val := bucket_storage_tally_remote.value()
	__remote_segments_count_val := bucket_storage_tally_remote_segments_count.value()
	__inline_segments_count_val := bucket_storage_tally_inline_segments_count.value()
	__object_count_val := bucket_storage_tally_object_count.value()
	__metadata_size_val := bucket_storage_tally_metadata_size.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_storage_tallies ( bucket_name, project_id, interval_start, inline, remote, remote_segments_count, inline_segments_count, object_count, metadata_size ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __bucket_name_val, __project_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)

	bucket_storage_tally = &BucketStorageTally{}
	err = obj.driver.QueryRow(__stmt, __bucket_name_val, __project_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val).Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_storage_tally, nil

}

func (obj *postgresImpl) Create_StoragenodeStorageTally(ctx context.Context,
	storagenode_storage_tally_node_id StoragenodeStorageTally_NodeId_Field,
	storagenode_storage_tally_interval_end_time StoragenodeStorageTally_IntervalEndTime_Field,
	storagenode_storage_tally_data_total StoragenodeStorageTally_DataTotal_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {
	__node_id_val := storagenode_storage_tally_node_id.value()
	__interval_end_time_val := storagenode_storage_tally_interval_end_time.value()
	__data_total_val := storagenode_storage_tally_data_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO storagenode_storage_tallies ( node_id, interval_end_time, data_total ) VALUES ( ?, ?, ? ) RETURNING storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __interval_end_time_val, __data_total_val)

	storagenode_storage_tally = &StoragenodeStorageTally{}
	err = obj.driver.QueryRow(__stmt, __node_id_val, __interval_end_time_val, __data_total_val).Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_storage_tally, nil

}

func (obj *postgresImpl) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__publickey_val := certRecord_publickey.value()
	__id_val := certRecord_id.value()
	__update_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO certRecords ( publickey, id, update_at ) VALUES ( ?, ?, ? ) RETURNING certRecords.publickey, certRecords.id, certRecords.update_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __publickey_val, __id_val, __update_at_val)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __publickey_val, __id_val, __update_at_val).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *postgresImpl) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := registration_token_secret.value()
	__owner_id_val := optional.OwnerId.value()
	__project_limit_val := registration_token_project_limit.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO registration_tokens ( secret, owner_id, project_limit, created_at ) VALUES ( ?, ?, ?, ? ) RETURNING registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Create_ResetPasswordToken(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := reset_password_token_secret.value()
	__owner_id_val := reset_password_token_owner_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO reset_password_tokens ( secret, owner_id, created_at ) VALUES ( ?, ?, ? ) RETURNING reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __created_at_val)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, __secret_val, __owner_id_val, __created_at_val).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *postgresImpl) Create_Offer(ctx context.Context,
	offer_name Offer_Name_Field,
	offer_description Offer_Description_Field,
	offer_award_credit_in_cents Offer_AwardCreditInCents_Field,
	offer_invitee_credit_in_cents Offer_InviteeCreditInCents_Field,
	offer_expires_at Offer_ExpiresAt_Field,
	offer_status Offer_Status_Field,
	offer_type Offer_Type_Field,
	optional Offer_Create_Fields) (
	offer *Offer, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__name_val := offer_name.value()
	__description_val := offer_description.value()
	__award_credit_in_cents_val := offer_award_credit_in_cents.value()
	__invitee_credit_in_cents_val := offer_invitee_credit_in_cents.value()
	__award_credit_duration_days_val := optional.AwardCreditDurationDays.value()
	__invitee_credit_duration_days_val := optional.InviteeCreditDurationDays.value()
	__redeemable_cap_val := optional.RedeemableCap.value()
	__expires_at_val := offer_expires_at.value()
	__created_at_val := __now
	__status_val := offer_status.value()
	__type_val := offer_type.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO offers ( name, description, award_credit_in_cents, invitee_credit_in_cents, award_credit_duration_days, invitee_credit_duration_days, redeemable_cap, expires_at, created_at, status, type ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __description_val, __award_credit_in_cents_val, __invitee_credit_in_cents_val, __award_credit_duration_days_val, __invitee_credit_duration_days_val, __redeemable_cap_val, __expires_at_val, __created_at_val, __status_val, __type_val)

	offer = &Offer{}
	err = obj.driver.QueryRow(__stmt, __name_val, __description_val, __award_credit_in_cents_val, __invitee_credit_in_cents_val, __award_credit_duration_days_val, __invitee_credit_duration_days_val, __redeemable_cap_val, __expires_at_val, __created_at_val, __status_val, __type_val).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil

}

func (obj *postgresImpl) Create_UserCredit(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_offer_id UserCredit_OfferId_Field,
	user_credit_credits_earned_in_cents UserCredit_CreditsEarnedInCents_Field,
	user_credit_expires_at UserCredit_ExpiresAt_Field,
	optional UserCredit_Create_Fields) (
	user_credit *UserCredit, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__user_id_val := user_credit_user_id.value()
	__offer_id_val := user_credit_offer_id.value()
	__referred_by_val := optional.ReferredBy.value()
	__credits_earned_in_cents_val := user_credit_credits_earned_in_cents.value()
	__credits_used_in_cents_val := int(0)
	__expires_at_val := user_credit_expires_at.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO user_credits ( user_id, offer_id, referred_by, credits_earned_in_cents, credits_used_in_cents, expires_at, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) RETURNING user_credits.id, user_credits.user_id, user_credits.offer_id, user_credits.referred_by, user_credits.credits_earned_in_cents, user_credits.credits_used_in_cents, user_credits.expires_at, user_credits.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __user_id_val, __offer_id_val, __referred_by_val, __credits_earned_in_cents_val, __credits_used_in_cents_val, __expires_at_val, __created_at_val)

	user_credit = &UserCredit{}
	err = obj.driver.QueryRow(__stmt, __user_id_val, __offer_id_val, __referred_by_val, __credits_earned_in_cents_val, __credits_used_in_cents_val, __expires_at_val, __created_at_val).Scan(&user_credit.Id, &user_credit.UserId, &user_credit.OfferId, &user_credit.ReferredBy, &user_credit.CreditsEarnedInCents, &user_credit.CreditsUsedInCents, &user_credit.ExpiresAt, &user_credit.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_credit, nil

}

func (obj *postgresImpl) Create_BucketMetainfo(ctx context.Context,
	bucket_metainfo_id BucketMetainfo_Id_Field,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	bucket_metainfo_path_cipher BucketMetainfo_PathCipher_Field,
	bucket_metainfo_default_segment_size BucketMetainfo_DefaultSegmentSize_Field,
	bucket_metainfo_default_encryption_cipher_suite BucketMetainfo_DefaultEncryptionCipherSuite_Field,
	bucket_metainfo_default_encryption_block_size BucketMetainfo_DefaultEncryptionBlockSize_Field,
	bucket_metainfo_default_redundancy_algorithm BucketMetainfo_DefaultRedundancyAlgorithm_Field,
	bucket_metainfo_default_redundancy_share_size BucketMetainfo_DefaultRedundancyShareSize_Field,
	bucket_metainfo_default_redundancy_required_shares BucketMetainfo_DefaultRedundancyRequiredShares_Field,
	bucket_metainfo_default_redundancy_repair_shares BucketMetainfo_DefaultRedundancyRepairShares_Field,
	bucket_metainfo_default_redundancy_optimal_shares BucketMetainfo_DefaultRedundancyOptimalShares_Field,
	bucket_metainfo_default_redundancy_total_shares BucketMetainfo_DefaultRedundancyTotalShares_Field,
	optional BucketMetainfo_Create_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := bucket_metainfo_id.value()
	__project_id_val := bucket_metainfo_project_id.value()
	__name_val := bucket_metainfo_name.value()
	__partner_id_val := optional.PartnerId.value()
	__path_cipher_val := bucket_metainfo_path_cipher.value()
	__created_at_val := __now
	__default_segment_size_val := bucket_metainfo_default_segment_size.value()
	__default_encryption_cipher_suite_val := bucket_metainfo_default_encryption_cipher_suite.value()
	__default_encryption_block_size_val := bucket_metainfo_default_encryption_block_size.value()
	__default_redundancy_algorithm_val := bucket_metainfo_default_redundancy_algorithm.value()
	__default_redundancy_share_size_val := bucket_metainfo_default_redundancy_share_size.value()
	__default_redundancy_required_shares_val := bucket_metainfo_default_redundancy_required_shares.value()
	__default_redundancy_repair_shares_val := bucket_metainfo_default_redundancy_repair_shares.value()
	__default_redundancy_optimal_shares_val := bucket_metainfo_default_redundancy_optimal_shares.value()
	__default_redundancy_total_shares_val := bucket_metainfo_default_redundancy_total_shares.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_metainfos ( id, project_id, name, partner_id, path_cipher, created_at, default_segment_size, default_encryption_cipher_suite, default_encryption_block_size, default_redundancy_algorithm, default_redundancy_share_size, default_redundancy_required_shares, default_redundancy_repair_shares, default_redundancy_optimal_shares, default_redundancy_total_shares ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __name_val, __partner_id_val, __path_cipher_val, __created_at_val, __default_segment_size_val, __default_encryption_cipher_suite_val, __default_encryption_block_size_val, __default_redundancy_algorithm_val, __default_redundancy_share_size_val, __default_redundancy_required_shares_val, __default_redundancy_repair_shares_val, __default_redundancy_optimal_shares_val, __default_redundancy_total_shares_val)

	bucket_metainfo = &BucketMetainfo{}
	err = obj.driver.QueryRow(__stmt, __id_val, __project_id_val, __name_val, __partner_id_val, __path_cipher_val, __created_at_val, __default_segment_size_val, __default_encryption_cipher_suite_val, __default_encryption_block_size_val, __default_redundancy_algorithm_val, __default_redundancy_share_size_val, __default_redundancy_required_shares_val, __default_redundancy_repair_shares_val, __default_redundancy_optimal_shares_val, __default_redundancy_total_shares_val).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil

}

func (obj *postgresImpl) Get_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	value_attribution *ValueAttribution, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT value_attributions.project_id, value_attributions.bucket_name, value_attributions.partner_id, value_attributions.last_updated FROM value_attributions WHERE value_attributions.project_id = ? AND value_attributions.bucket_name = ?")

	var __values []interface{}
	__values = append(__values, value_attribution_project_id.value(), value_attribution_bucket_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	value_attribution = &ValueAttribution{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&value_attribution.ProjectId, &value_attribution.BucketName, &value_attribution.PartnerId, &value_attribution.LastUpdated)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return value_attribution, nil

}

func (obj *postgresImpl) Get_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	pending_audits *PendingAudits, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path FROM pending_audits WHERE pending_audits.node_id = ?")

	var __values []interface{}
	__values = append(__values, pending_audits_node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pending_audits = &PendingAudits{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil

}

func (obj *postgresImpl) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *postgresImpl) Limited_Irreparabledb_By_Segmentpath_Greater_OrderBy_Asc_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath_greater Irreparabledb_Segmentpath_Field,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath > ? ORDER BY irreparabledbs.segmentpath LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath_greater.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		irreparabledb := &Irreparabledb{}
		err = __rows.Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, irreparabledb)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __values []interface{}
	__values = append(__values, accounting_timestamps_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &Value_Row{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&row.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return row, nil

}

func (obj *postgresImpl) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *postgresImpl) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.start_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_start_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_rollup := &AccountingRollup{}
		err = __rows.Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *postgresImpl) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id FROM nodes")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_Row{}
		err = __rows.Scan(&row.Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE nodes.id >= ? ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		node := &Node{}
		err = __rows.Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, node)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_Node_Id_Node_LastNet_Node_Address_Node_Protocol_By_Id_GreaterOrEqual_And_Disqualified_Is_Null_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Id_LastNet_Address_Protocol_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.last_net, nodes.address, nodes.protocol FROM nodes WHERE nodes.id >= ? AND nodes.disqualified is NULL ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_LastNet_Address_Protocol_Row{}
		err = __rows.Scan(&row.Id, &row.LastNet, &row.Address, &row.Protocol)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE users.email = ? AND users.status != 0 LIMIT 2")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	user = &User{}
	err = __rows.Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("User_By_Email_And_Status_Not_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return user, nil

}

func (obj *postgresImpl) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Get_UserPayment_By_UserId(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field) (
	user_payment *UserPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_payments.user_id, user_payments.customer_id, user_payments.created_at FROM user_payments WHERE user_payments.user_id = ?")

	var __values []interface{}
	__values = append(__values, user_payment_user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user_payment = &UserPayment{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user_payment.UserId, &user_payment.CustomerId, &user_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_payment, nil

}

func (obj *postgresImpl) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *postgresImpl) All_Project(ctx context.Context) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Project_By_CreatedAt_Less_OrderBy_Asc_CreatedAt(ctx context.Context,
	project_created_at_less Project_CreatedAt_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE projects.created_at < ? ORDER BY projects.created_at")

	var __values []interface{}
	__values = append(__values, project_created_at_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects  JOIN project_members ON projects.id = project_members.project_id WHERE project_members.member_id = ? ORDER BY projects.name")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	project_payment *ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project_payment = &ProjectPayment{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil

}

func (obj *postgresImpl) Get_ProjectPayment_By_ProjectId_And_IsDefault_Equal_True(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	project_payment *ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.project_id = ? AND project_payments.is_default = true LIMIT 2")

	var __values []interface{}
	__values = append(__values, project_payment_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	project_payment = &ProjectPayment{}
	err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("ProjectPayment_By_ProjectId_And_IsDefault_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return project_payment, nil

}

func (obj *postgresImpl) All_ProjectPayment_By_ProjectId(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	rows []*ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_payment := &ProjectPayment{}
		err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_payment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_ProjectPayment_By_PayerId(ctx context.Context,
	project_payment_payer_id ProjectPayment_PayerId_Field) (
	rows []*ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.payer_id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_payer_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_payment := &ProjectPayment{}
		err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_payment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_ProjectInvoiceStamp_By_ProjectId_And_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at FROM project_invoice_stamps WHERE project_invoice_stamps.project_id = ? AND project_invoice_stamps.start_date = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, project_invoice_stamp_project_id.value(), project_invoice_stamp_start_date.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	project_invoice_stamp = &ProjectInvoiceStamp{}
	err = __rows.Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("ProjectInvoiceStamp_By_ProjectId_And_StartDate")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return project_invoice_stamp, nil

}

func (obj *postgresImpl) All_ProjectInvoiceStamp_By_ProjectId_OrderBy_Desc_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field) (
	rows []*ProjectInvoiceStamp, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at FROM project_invoice_stamps WHERE project_invoice_stamps.project_id = ? ORDER BY project_invoice_stamps.start_date DESC")

	var __values []interface{}
	__values = append(__values, project_invoice_stamp_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_invoice_stamp := &ProjectInvoiceStamp{}
		err = __rows.Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_invoice_stamp)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.member_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.project_id = ? LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, project_member_project_id.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) Get_ApiKey_By_Head(ctx context.Context,
	api_key_head ApiKey_Head_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.head = ?")

	var __values []interface{}
	__values = append(__values, api_key_head.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.project_id = ? ORDER BY api_keys.name")

	var __values []interface{}
	__values = append(__values, api_key_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		api_key := &ApiKey{}
		err = __rows.Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, api_key)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *postgresImpl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time DESC LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE serial_numbers.serial_number = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, serial_number_serial_number.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	serial_number = &SerialNumber{}
	err = __rows.Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("SerialNumber_By_SerialNumber")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return serial_number, nil

}

func (obj *postgresImpl) Find_BucketBandwidthRollup_By_BucketName_And_ProjectId_And_IntervalStart_And_Action(ctx context.Context,
	bucket_bandwidth_rollup_bucket_name BucketBandwidthRollup_BucketName_Field,
	bucket_bandwidth_rollup_project_id BucketBandwidthRollup_ProjectId_Field,
	bucket_bandwidth_rollup_interval_start BucketBandwidthRollup_IntervalStart_Field,
	bucket_bandwidth_rollup_action BucketBandwidthRollup_Action_Field) (
	bucket_bandwidth_rollup *BucketBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_bandwidth_rollups.bucket_name, bucket_bandwidth_rollups.project_id, bucket_bandwidth_rollups.interval_start, bucket_bandwidth_rollups.interval_seconds, bucket_bandwidth_rollups.action, bucket_bandwidth_rollups.inline, bucket_bandwidth_rollups.allocated, bucket_bandwidth_rollups.settled FROM bucket_bandwidth_rollups WHERE bucket_bandwidth_rollups.bucket_name = ? AND bucket_bandwidth_rollups.project_id = ? AND bucket_bandwidth_rollups.interval_start = ? AND bucket_bandwidth_rollups.action = ?")

	var __values []interface{}
	__values = append(__values, bucket_bandwidth_rollup_bucket_name.value(), bucket_bandwidth_rollup_project_id.value(), bucket_bandwidth_rollup_interval_start.value(), bucket_bandwidth_rollup_action.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_bandwidth_rollup = &BucketBandwidthRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_bandwidth_rollup.BucketName, &bucket_bandwidth_rollup.ProjectId, &bucket_bandwidth_rollup.IntervalStart, &bucket_bandwidth_rollup.IntervalSeconds, &bucket_bandwidth_rollup.Action, &bucket_bandwidth_rollup.Inline, &bucket_bandwidth_rollup.Allocated, &bucket_bandwidth_rollup.Settled)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_bandwidth_rollup, nil

}

func (obj *postgresImpl) First_BucketStorageTally_By_ProjectId_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE bucket_storage_tallies.project_id = ? ORDER BY bucket_storage_tallies.interval_start DESC LIMIT 1 OFFSET 0")

	var __values []interface{}
	__values = append(__values, bucket_storage_tally_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	bucket_storage_tally = &BucketStorageTally{}
	err = __rows.Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return bucket_storage_tally, nil

}

func (obj *postgresImpl) All_BucketStorageTally_By_ProjectId_And_BucketName_And_IntervalStart_GreaterOrEqual_And_IntervalStart_LessOrEqual_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_interval_start_greater_or_equal BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_interval_start_less_or_equal BucketStorageTally_IntervalStart_Field) (
	rows []*BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE bucket_storage_tallies.project_id = ? AND bucket_storage_tallies.bucket_name = ? AND bucket_storage_tallies.interval_start >= ? AND bucket_storage_tallies.interval_start <= ? ORDER BY bucket_storage_tallies.interval_start DESC")

	var __values []interface{}
	__values = append(__values, bucket_storage_tally_project_id.value(), bucket_storage_tally_bucket_name.value(), bucket_storage_tally_interval_start_greater_or_equal.value(), bucket_storage_tally_interval_start_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_storage_tally := &BucketStorageTally{}
		err = __rows.Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_StoragenodeBandwidthRollup_By_StoragenodeId_And_IntervalStart_And_Action(ctx context.Context,
	storagenode_bandwidth_rollup_storagenode_id StoragenodeBandwidthRollup_StoragenodeId_Field,
	storagenode_bandwidth_rollup_interval_start StoragenodeBandwidthRollup_IntervalStart_Field,
	storagenode_bandwidth_rollup_action StoragenodeBandwidthRollup_Action_Field) (
	storagenode_bandwidth_rollup *StoragenodeBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_bandwidth_rollups.storagenode_id, storagenode_bandwidth_rollups.interval_start, storagenode_bandwidth_rollups.interval_seconds, storagenode_bandwidth_rollups.action, storagenode_bandwidth_rollups.allocated, storagenode_bandwidth_rollups.settled FROM storagenode_bandwidth_rollups WHERE storagenode_bandwidth_rollups.storagenode_id = ? AND storagenode_bandwidth_rollups.interval_start = ? AND storagenode_bandwidth_rollups.action = ?")

	var __values []interface{}
	__values = append(__values, storagenode_bandwidth_rollup_storagenode_id.value(), storagenode_bandwidth_rollup_interval_start.value(), storagenode_bandwidth_rollup_action.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	storagenode_bandwidth_rollup = &StoragenodeBandwidthRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&storagenode_bandwidth_rollup.StoragenodeId, &storagenode_bandwidth_rollup.IntervalStart, &storagenode_bandwidth_rollup.IntervalSeconds, &storagenode_bandwidth_rollup.Action, &storagenode_bandwidth_rollup.Allocated, &storagenode_bandwidth_rollup.Settled)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_bandwidth_rollup, nil

}

func (obj *postgresImpl) All_StoragenodeBandwidthRollup_By_IntervalStart_GreaterOrEqual(ctx context.Context,
	storagenode_bandwidth_rollup_interval_start_greater_or_equal StoragenodeBandwidthRollup_IntervalStart_Field) (
	rows []*StoragenodeBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_bandwidth_rollups.storagenode_id, storagenode_bandwidth_rollups.interval_start, storagenode_bandwidth_rollups.interval_seconds, storagenode_bandwidth_rollups.action, storagenode_bandwidth_rollups.allocated, storagenode_bandwidth_rollups.settled FROM storagenode_bandwidth_rollups WHERE storagenode_bandwidth_rollups.interval_start >= ?")

	var __values []interface{}
	__values = append(__values, storagenode_bandwidth_rollup_interval_start_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_bandwidth_rollup := &StoragenodeBandwidthRollup{}
		err = __rows.Scan(&storagenode_bandwidth_rollup.StoragenodeId, &storagenode_bandwidth_rollup.IntervalStart, &storagenode_bandwidth_rollup.IntervalSeconds, &storagenode_bandwidth_rollup.Action, &storagenode_bandwidth_rollup.Allocated, &storagenode_bandwidth_rollup.Settled)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_bandwidth_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.id = ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	storagenode_storage_tally = &StoragenodeStorageTally{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_storage_tally, nil

}

func (obj *postgresImpl) All_StoragenodeStorageTally(ctx context.Context) (
	rows []*StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_storage_tally := &StoragenodeStorageTally{}
		err = __rows.Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_StoragenodeStorageTally_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	storagenode_storage_tally_interval_end_time_greater_or_equal StoragenodeStorageTally_IntervalEndTime_Field) (
	rows []*StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.interval_end_time >= ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_interval_end_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_storage_tally := &StoragenodeStorageTally{}
		err = __rows.Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *postgresImpl) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, registration_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "registration_tokens.owner_id", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !registration_token_owner_id.isnull() {
		__cond_0.Null = false
		__values = append(__values, registration_token_owner_id.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Get_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at FROM reset_password_tokens WHERE reset_password_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *postgresImpl) Get_ResetPasswordToken_By_OwnerId(ctx context.Context,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at FROM reset_password_tokens WHERE reset_password_tokens.owner_id = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_owner_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *postgresImpl) Get_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field) (
	offer *Offer, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers WHERE offers.id = ?")

	var __values []interface{}
	__values = append(__values, offer_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	offer = &Offer{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil

}

func (obj *postgresImpl) All_Offer_OrderBy_Asc_Id(ctx context.Context) (
	rows []*Offer, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers ORDER BY offers.id")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		offer := &Offer{}
		err = __rows.Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, offer)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_UserCredit_By_UserId_And_ExpiresAt_Greater_And_CreditsUsedInCents_Less_CreditsEarnedInCents_OrderBy_Asc_ExpiresAt(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_expires_at_greater UserCredit_ExpiresAt_Field) (
	rows []*UserCredit, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_credits.id, user_credits.user_id, user_credits.offer_id, user_credits.referred_by, user_credits.credits_earned_in_cents, user_credits.credits_used_in_cents, user_credits.expires_at, user_credits.created_at FROM user_credits WHERE user_credits.user_id = ? AND user_credits.expires_at > ? AND user_credits.credits_used_in_cents < user_credits.credits_earned_in_cents ORDER BY user_credits.expires_at")

	var __values []interface{}
	__values = append(__values, user_credit_user_id.value(), user_credit_expires_at_greater.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		user_credit := &UserCredit{}
		err = __rows.Scan(&user_credit.Id, &user_credit.UserId, &user_credit.OfferId, &user_credit.ReferredBy, &user_credit.CreditsEarnedInCents, &user_credit.CreditsUsedInCents, &user_credit.ExpiresAt, &user_credit.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, user_credit)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Count_UserCredit_By_ReferredBy(ctx context.Context,
	user_credit_referred_by UserCredit_ReferredBy_Field) (
	count int64, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "user_credits.referred_by", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT COUNT(*) FROM user_credits WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !user_credit_referred_by.isnull() {
		__cond_0.Null = false
		__values = append(__values, user_credit_referred_by.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRow(__stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *postgresImpl) Get_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	bucket_metainfo *BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_metainfo = &BucketMetainfo{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil

}

func (obj *postgresImpl) Limited_BucketMetainfo_By_ProjectId_And_Name_GreaterOrEqual_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater_or_equal BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name >= ? ORDER BY bucket_metainfos.name LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_metainfo := &BucketMetainfo{}
		err = __rows.Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_metainfo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_BucketMetainfo_By_ProjectId_And_Name_Greater_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name > ? ORDER BY bucket_metainfos.name LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name_greater.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_metainfo := &BucketMetainfo{}
		err = __rows.Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_metainfo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Update_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	update PendingAudits_Update_Fields) (
	pending_audits *PendingAudits, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE pending_audits SET "), __sets, __sqlbundle_Literal(" WHERE pending_audits.node_id = ? RETURNING pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.ReverifyCount._set {
		__values = append(__values, update.ReverifyCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("reverify_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, pending_audits_node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pending_audits = &PendingAudits{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil
}

func (obj *postgresImpl) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE irreparabledbs SET "), __sets, __sqlbundle_Literal(" WHERE irreparabledbs.segmentpath = ? RETURNING irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Segmentdetail._set {
		__values = append(__values, update.Segmentdetail.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("segmentdetail = ?"))
	}

	if update.PiecesLostCount._set {
		__values = append(__values, update.PiecesLostCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("pieces_lost_count = ?"))
	}

	if update.SegDamagedUnixSec._set {
		__values = append(__values, update.SegDamagedUnixSec.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("seg_damaged_unix_sec = ?"))
	}

	if update.RepairAttemptCount._set {
		__values = append(__values, update.RepairAttemptCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("repair_attempt_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, irreparabledb_segmentpath.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil
}

func (obj *postgresImpl) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE accounting_timestamps SET "), __sets, __sqlbundle_Literal(" WHERE accounting_timestamps.name = ? RETURNING accounting_timestamps.name, accounting_timestamps.value")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Value._set {
		__values = append(__values, update.Value.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, accounting_timestamps_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil
}

func (obj *postgresImpl) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE nodes SET "), __sets, __sqlbundle_Literal(" WHERE nodes.id = ? RETURNING nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Address._set {
		__values = append(__values, update.Address.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("address = ?"))
	}

	if update.LastNet._set {
		__values = append(__values, update.LastNet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_net = ?"))
	}

	if update.Protocol._set {
		__values = append(__values, update.Protocol.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("protocol = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.Wallet._set {
		__values = append(__values, update.Wallet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("wallet = ?"))
	}

	if update.FreeBandwidth._set {
		__values = append(__values, update.FreeBandwidth.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_bandwidth = ?"))
	}

	if update.FreeDisk._set {
		__values = append(__values, update.FreeDisk.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_disk = ?"))
	}

	if update.Major._set {
		__values = append(__values, update.Major.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("major = ?"))
	}

	if update.Minor._set {
		__values = append(__values, update.Minor.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("minor = ?"))
	}

	if update.Patch._set {
		__values = append(__values, update.Patch.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("patch = ?"))
	}

	if update.Hash._set {
		__values = append(__values, update.Hash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("hash = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Release._set {
		__values = append(__values, update.Release.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("release = ?"))
	}

	if update.Latency90._set {
		__values = append(__values, update.Latency90.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("latency_90 = ?"))
	}

	if update.AuditSuccessCount._set {
		__values = append(__values, update.AuditSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_count = ?"))
	}

	if update.TotalAuditCount._set {
		__values = append(__values, update.TotalAuditCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_audit_count = ?"))
	}

	if update.UptimeSuccessCount._set {
		__values = append(__values, update.UptimeSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_success_count = ?"))
	}

	if update.TotalUptimeCount._set {
		__values = append(__values, update.TotalUptimeCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_uptime_count = ?"))
	}

	if update.LastContactSuccess._set {
		__values = append(__values, update.LastContactSuccess.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_success = ?"))
	}

	if update.LastContactFailure._set {
		__values = append(__values, update.LastContactFailure.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_failure = ?"))
	}

	if update.Contained._set {
		__values = append(__values, update.Contained.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("contained = ?"))
	}

	if update.Disqualified._set {
		__values = append(__values, update.Disqualified.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("disqualified = ?"))
	}

	if update.AuditReputationAlpha._set {
		__values = append(__values, update.AuditReputationAlpha.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_reputation_alpha = ?"))
	}

	if update.AuditReputationBeta._set {
		__values = append(__values, update.AuditReputationBeta.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_reputation_beta = ?"))
	}

	if update.UptimeReputationAlpha._set {
		__values = append(__values, update.UptimeReputationAlpha.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_reputation_alpha = ?"))
	}

	if update.UptimeReputationBeta._set {
		__values = append(__values, update.UptimeReputationBeta.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_reputation_beta = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil
}

func (obj *postgresImpl) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE users SET "), __sets, __sqlbundle_Literal(" WHERE users.id = ? RETURNING users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.FullName._set {
		__values = append(__values, update.FullName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("full_name = ?"))
	}

	if update.ShortName._set {
		__values = append(__values, update.ShortName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("short_name = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, user_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil
}

func (obj *postgresImpl) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE projects SET "), __sets, __sqlbundle_Literal(" WHERE projects.id = ? RETURNING projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.UsageLimit._set {
		__values = append(__values, update.UsageLimit.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("usage_limit = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil
}

func (obj *postgresImpl) Update_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	update ProjectPayment_Update_Fields) (
	project_payment *ProjectPayment, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE project_payments SET "), __sets, __sqlbundle_Literal(" WHERE project_payments.id = ? RETURNING project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.IsDefault._set {
		__values = append(__values, update.IsDefault.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("is_default = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_payment_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project_payment = &ProjectPayment{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil
}

func (obj *postgresImpl) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE api_keys SET "), __sets, __sqlbundle_Literal(" WHERE api_keys.id = ? RETURNING api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, api_key_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil
}

func (obj *postgresImpl) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE certRecords SET "), __sets, __sqlbundle_Literal(" WHERE certRecords.id = ? RETURNING certRecords.publickey, certRecords.id, certRecords.update_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("update_at = ?"))

	__args = append(__args, certRecord_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil
}

func (obj *postgresImpl) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE registration_tokens SET "), __sets, __sqlbundle_Literal(" WHERE registration_tokens.secret = ? RETURNING registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.OwnerId._set {
		__values = append(__values, update.OwnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("owner_id = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, registration_token_secret.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil
}

func (obj *postgresImpl) Update_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field,
	update Offer_Update_Fields) (
	offer *Offer, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE offers SET "), __sets, __sqlbundle_Literal(" WHERE offers.id = ? RETURNING offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.AwardCreditInCents._set {
		__values = append(__values, update.AwardCreditInCents.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("award_credit_in_cents = ?"))
	}

	if update.InviteeCreditInCents._set {
		__values = append(__values, update.InviteeCreditInCents.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("invitee_credit_in_cents = ?"))
	}

	if update.AwardCreditDurationDays._set {
		__values = append(__values, update.AwardCreditDurationDays.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("award_credit_duration_days = ?"))
	}

	if update.InviteeCreditDurationDays._set {
		__values = append(__values, update.InviteeCreditDurationDays.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("invitee_credit_duration_days = ?"))
	}

	if update.RedeemableCap._set {
		__values = append(__values, update.RedeemableCap.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("redeemable_cap = ?"))
	}

	if update.ExpiresAt._set {
		__values = append(__values, update.ExpiresAt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("expires_at = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, offer_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	offer = &Offer{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil
}

func (obj *postgresImpl) Update_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	update BucketMetainfo_Update_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bucket_metainfos SET "), __sets, __sqlbundle_Literal(" WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ? RETURNING bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.PartnerId._set {
		__values = append(__values, update.PartnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("partner_id = ?"))
	}

	if update.DefaultSegmentSize._set {
		__values = append(__values, update.DefaultSegmentSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_segment_size = ?"))
	}

	if update.DefaultEncryptionCipherSuite._set {
		__values = append(__values, update.DefaultEncryptionCipherSuite.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_encryption_cipher_suite = ?"))
	}

	if update.DefaultEncryptionBlockSize._set {
		__values = append(__values, update.DefaultEncryptionBlockSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_encryption_block_size = ?"))
	}

	if update.DefaultRedundancyAlgorithm._set {
		__values = append(__values, update.DefaultRedundancyAlgorithm.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_algorithm = ?"))
	}

	if update.DefaultRedundancyShareSize._set {
		__values = append(__values, update.DefaultRedundancyShareSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_share_size = ?"))
	}

	if update.DefaultRedundancyRequiredShares._set {
		__values = append(__values, update.DefaultRedundancyRequiredShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_required_shares = ?"))
	}

	if update.DefaultRedundancyRepairShares._set {
		__values = append(__values, update.DefaultRedundancyRepairShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_repair_shares = ?"))
	}

	if update.DefaultRedundancyOptimalShares._set {
		__values = append(__values, update.DefaultRedundancyOptimalShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_optimal_shares = ?"))
	}

	if update.DefaultRedundancyTotalShares._set {
		__values = append(__values, update.DefaultRedundancyTotalShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_total_shares = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_metainfo = &BucketMetainfo{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil
}

func (obj *postgresImpl) Delete_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM value_attributions WHERE value_attributions.project_id = ? AND value_attributions.bucket_name = ?")

	var __values []interface{}
	__values = append(__values, value_attribution_project_id.value(), value_attribution_bucket_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM pending_audits WHERE pending_audits.node_id = ?")

	var __values []interface{}
	__values = append(__values, pending_audits_node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_payments WHERE project_payments.id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_members WHERE project_members.member_id = ? AND project_members.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value(), project_member_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM serial_numbers WHERE serial_numbers.expires_at <= ?")

	var __values []interface{}
	__values = append(__values, serial_number_expires_at_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *postgresImpl) Delete_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.id = ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM reset_password_tokens WHERE reset_password_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (impl postgresImpl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(*pq.Error); ok {
		if e.Code.Class() == "23" {
			return e.Constraint, true
		}
	}
	return "", false
}

func (obj *postgresImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM project_payments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM user_payments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM user_credits;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM used_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_members;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_invoice_stamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_metainfos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM api_keys;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM value_attributions;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM serial_numbers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM reset_password_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM registration_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM projects;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM pending_audits;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM offers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM nodes;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM irreparabledbs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM injuredsegments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM certRecords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_usages;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *sqlite3Impl) Create_ValueAttribution(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field,
	value_attribution_partner_id ValueAttribution_PartnerId_Field) (
	value_attribution *ValueAttribution, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__project_id_val := value_attribution_project_id.value()
	__bucket_name_val := value_attribution_bucket_name.value()
	__partner_id_val := value_attribution_partner_id.value()
	__last_updated_val := __now.UTC()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO value_attributions ( project_id, bucket_name, partner_id, last_updated ) VALUES ( ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __project_id_val, __bucket_name_val, __partner_id_val, __last_updated_val)

	__res, err := obj.driver.Exec(__stmt, __project_id_val, __bucket_name_val, __partner_id_val, __last_updated_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastValueAttribution(ctx, __pk)

}

func (obj *sqlite3Impl) Create_PendingAudits(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	pending_audits_piece_id PendingAudits_PieceId_Field,
	pending_audits_stripe_index PendingAudits_StripeIndex_Field,
	pending_audits_share_size PendingAudits_ShareSize_Field,
	pending_audits_expected_share_hash PendingAudits_ExpectedShareHash_Field,
	pending_audits_reverify_count PendingAudits_ReverifyCount_Field,
	pending_audits_path PendingAudits_Path_Field) (
	pending_audits *PendingAudits, err error) {
	__node_id_val := pending_audits_node_id.value()
	__piece_id_val := pending_audits_piece_id.value()
	__stripe_index_val := pending_audits_stripe_index.value()
	__share_size_val := pending_audits_share_size.value()
	__expected_share_hash_val := pending_audits_expected_share_hash.value()
	__reverify_count_val := pending_audits_reverify_count.value()
	__path_val := pending_audits_path.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO pending_audits ( node_id, piece_id, stripe_index, share_size, expected_share_hash, reverify_count, path ) VALUES ( ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __piece_id_val, __stripe_index_val, __share_size_val, __expected_share_hash_val, __reverify_count_val, __path_val)

	__res, err := obj.driver.Exec(__stmt, __node_id_val, __piece_id_val, __stripe_index_val, __share_size_val, __expected_share_hash_val, __reverify_count_val, __path_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastPendingAudits(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	__segmentpath_val := irreparabledb_segmentpath.value()
	__segmentdetail_val := irreparabledb_segmentdetail.value()
	__pieces_lost_count_val := irreparabledb_pieces_lost_count.value()
	__seg_damaged_unix_sec_val := irreparabledb_seg_damaged_unix_sec.value()
	__repair_attempt_count_val := irreparabledb_repair_attempt_count.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO irreparabledbs ( segmentpath, segmentdetail, pieces_lost_count, seg_damaged_unix_sec, repair_attempt_count ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)

	__res, err := obj.driver.Exec(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastIrreparabledb(ctx, __pk)

}

func (obj *sqlite3Impl) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	__name_val := accounting_timestamps_name.value()
	__value_val := accounting_timestamps_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_timestamps ( name, value ) VALUES ( ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __value_val)

	__res, err := obj.driver.Exec(__stmt, __name_val, __value_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAccountingTimestamps(ctx, __pk)

}

func (obj *sqlite3Impl) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	__node_id_val := accounting_rollup_node_id.value()
	__start_time_val := accounting_rollup_start_time.value()
	__put_total_val := accounting_rollup_put_total.value()
	__get_total_val := accounting_rollup_get_total.value()
	__get_audit_total_val := accounting_rollup_get_audit_total.value()
	__get_repair_total_val := accounting_rollup_get_repair_total.value()
	__put_repair_total_val := accounting_rollup_put_repair_total.value()
	__at_rest_total_val := accounting_rollup_at_rest_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_rollups ( node_id, start_time, put_total, get_total, get_audit_total, get_repair_total, put_repair_total, at_rest_total ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)

	__res, err := obj.driver.Exec(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAccountingRollup(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_last_net Node_LastNet_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_major Node_Major_Field,
	node_minor Node_Minor_Field,
	node_patch Node_Patch_Field,
	node_hash Node_Hash_Field,
	node_timestamp Node_Timestamp_Field,
	node_release Node_Release_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field,
	node_contained Node_Contained_Field,
	node_audit_reputation_alpha Node_AuditReputationAlpha_Field,
	node_audit_reputation_beta Node_AuditReputationBeta_Field,
	node_uptime_reputation_alpha Node_UptimeReputationAlpha_Field,
	node_uptime_reputation_beta Node_UptimeReputationBeta_Field,
	optional Node_Create_Fields) (
	node *Node, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := node_id.value()
	__address_val := node_address.value()
	__last_net_val := node_last_net.value()
	__protocol_val := node_protocol.value()
	__type_val := node_type.value()
	__email_val := node_email.value()
	__wallet_val := node_wallet.value()
	__free_bandwidth_val := node_free_bandwidth.value()
	__free_disk_val := node_free_disk.value()
	__major_val := node_major.value()
	__minor_val := node_minor.value()
	__patch_val := node_patch.value()
	__hash_val := node_hash.value()
	__timestamp_val := node_timestamp.value()
	__release_val := node_release.value()
	__latency_90_val := node_latency_90.value()
	__audit_success_count_val := node_audit_success_count.value()
	__total_audit_count_val := node_total_audit_count.value()
	__uptime_success_count_val := node_uptime_success_count.value()
	__total_uptime_count_val := node_total_uptime_count.value()
	__created_at_val := __now
	__updated_at_val := __now
	__last_contact_success_val := node_last_contact_success.value()
	__last_contact_failure_val := node_last_contact_failure.value()
	__contained_val := node_contained.value()
	__disqualified_val := optional.Disqualified.value()
	__audit_reputation_alpha_val := node_audit_reputation_alpha.value()
	__audit_reputation_beta_val := node_audit_reputation_beta.value()
	__uptime_reputation_alpha_val := node_uptime_reputation_alpha.value()
	__uptime_reputation_beta_val := node_uptime_reputation_beta.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO nodes ( id, address, last_net, protocol, type, email, wallet, free_bandwidth, free_disk, major, minor, patch, hash, timestamp, release, latency_90, audit_success_count, total_audit_count, uptime_success_count, total_uptime_count, created_at, updated_at, last_contact_success, last_contact_failure, contained, disqualified, audit_reputation_alpha, audit_reputation_beta, uptime_reputation_alpha, uptime_reputation_beta ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __address_val, __last_net_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __major_val, __minor_val, __patch_val, __hash_val, __timestamp_val, __release_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __uptime_success_count_val, __total_uptime_count_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val, __contained_val, __disqualified_val, __audit_reputation_alpha_val, __audit_reputation_beta_val, __uptime_reputation_alpha_val, __uptime_reputation_beta_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __address_val, __last_net_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __major_val, __minor_val, __patch_val, __hash_val, __timestamp_val, __release_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __uptime_success_count_val, __total_uptime_count_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val, __contained_val, __disqualified_val, __audit_reputation_alpha_val, __audit_reputation_beta_val, __uptime_reputation_alpha_val, __uptime_reputation_beta_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastNode(ctx, __pk)

}

func (obj *sqlite3Impl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_full_name User_FullName_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__email_val := user_email.value()
	__full_name_val := user_full_name.value()
	__short_name_val := optional.ShortName.value()
	__password_hash_val := user_password_hash.value()
	__status_val := int(0)
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, email, full_name, short_name, password_hash, status, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __email_val, __full_name_val, __short_name_val, __password_hash_val, __status_val, __partner_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __email_val, __full_name_val, __short_name_val, __password_hash_val, __status_val, __partner_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUser(ctx, __pk)

}

func (obj *sqlite3Impl) Create_UserPayment(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field,
	user_payment_customer_id UserPayment_CustomerId_Field) (
	user_payment *UserPayment, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__user_id_val := user_payment_user_id.value()
	__customer_id_val := user_payment_customer_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO user_payments ( user_id, customer_id, created_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __user_id_val, __customer_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __user_id_val, __customer_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUserPayment(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field,
	project_usage_limit Project_UsageLimit_Field,
	optional Project_Create_Fields) (
	project *Project, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_id.value()
	__name_val := project_name.value()
	__description_val := project_description.value()
	__usage_limit_val := project_usage_limit.value()
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO projects ( id, name, description, usage_limit, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __name_val, __description_val, __usage_limit_val, __partner_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __name_val, __description_val, __usage_limit_val, __partner_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProject(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ProjectPayment(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	project_payment_project_id ProjectPayment_ProjectId_Field,
	project_payment_payer_id ProjectPayment_PayerId_Field,
	project_payment_payment_method_id ProjectPayment_PaymentMethodId_Field,
	project_payment_is_default ProjectPayment_IsDefault_Field) (
	project_payment *ProjectPayment, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_payment_id.value()
	__project_id_val := project_payment_project_id.value()
	__payer_id_val := project_payment_payer_id.value()
	__payment_method_id_val := project_payment_payment_method_id.value()
	__is_default_val := project_payment_is_default.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_payments ( id, project_id, payer_id, payment_method_id, is_default, created_at ) VALUES ( ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __payer_id_val, __payment_method_id_val, __is_default_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __project_id_val, __payer_id_val, __payment_method_id_val, __is_default_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProjectPayment(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ProjectInvoiceStamp(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_invoice_id ProjectInvoiceStamp_InvoiceId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field,
	project_invoice_stamp_end_date ProjectInvoiceStamp_EndDate_Field,
	project_invoice_stamp_created_at ProjectInvoiceStamp_CreatedAt_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {
	__project_id_val := project_invoice_stamp_project_id.value()
	__invoice_id_val := project_invoice_stamp_invoice_id.value()
	__start_date_val := project_invoice_stamp_start_date.value()
	__end_date_val := project_invoice_stamp_end_date.value()
	__created_at_val := project_invoice_stamp_created_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_invoice_stamps ( project_id, invoice_id, start_date, end_date, created_at ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __project_id_val, __invoice_id_val, __start_date_val, __end_date_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __project_id_val, __invoice_id_val, __start_date_val, __end_date_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProjectInvoiceStamp(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__member_id_val := project_member_member_id.value()
	__project_id_val := project_member_project_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_members ( member_id, project_id, created_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __member_id_val, __project_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __member_id_val, __project_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProjectMember(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_head ApiKey_Head_Field,
	api_key_name ApiKey_Name_Field,
	api_key_secret ApiKey_Secret_Field,
	optional ApiKey_Create_Fields) (
	api_key *ApiKey, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := api_key_id.value()
	__project_id_val := api_key_project_id.value()
	__head_val := api_key_head.value()
	__name_val := api_key_name.value()
	__secret_val := api_key_secret.value()
	__partner_id_val := optional.PartnerId.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO api_keys ( id, project_id, head, name, secret, partner_id, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __head_val, __name_val, __secret_val, __partner_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __project_id_val, __head_val, __name_val, __secret_val, __partner_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastApiKey(ctx, __pk)

}

func (obj *sqlite3Impl) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	__id_val := bucket_usage_id.value()
	__bucket_id_val := bucket_usage_bucket_id.value()
	__rollup_end_time_val := bucket_usage_rollup_end_time.value()
	__remote_stored_data_val := bucket_usage_remote_stored_data.value()
	__inline_stored_data_val := bucket_usage_inline_stored_data.value()
	__remote_segments_val := bucket_usage_remote_segments.value()
	__inline_segments_val := bucket_usage_inline_segments.value()
	__objects_val := bucket_usage_objects.value()
	__metadata_size_val := bucket_usage_metadata_size.value()
	__repair_egress_val := bucket_usage_repair_egress.value()
	__get_egress_val := bucket_usage_get_egress.value()
	__audit_egress_val := bucket_usage_audit_egress.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_usages ( id, bucket_id, rollup_end_time, remote_stored_data, inline_stored_data, remote_segments, inline_segments, objects, metadata_size, repair_egress, get_egress, audit_egress ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastBucketUsage(ctx, __pk)

}

func (obj *sqlite3Impl) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	__serial_number_val := serial_number_serial_number.value()
	__bucket_id_val := serial_number_bucket_id.value()
	__expires_at_val := serial_number_expires_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO serial_numbers ( serial_number, bucket_id, expires_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)

	__res, err := obj.driver.Exec(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastSerialNumber(ctx, __pk)

}

func (obj *sqlite3Impl) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	__serial_number_id_val := used_serial_serial_number_id.value()
	__storage_node_id_val := used_serial_storage_node_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO used_serials ( serial_number_id, storage_node_id ) VALUES ( ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_id_val, __storage_node_id_val)

	__res, err := obj.driver.Exec(__stmt, __serial_number_id_val, __storage_node_id_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUsedSerial(ctx, __pk)

}

func (obj *sqlite3Impl) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	__bucket_name_val := bucket_storage_tally_bucket_name.value()
	__project_id_val := bucket_storage_tally_project_id.value()
	__interval_start_val := bucket_storage_tally_interval_start.value()
	__inline_val := bucket_storage_tally_inline.value()
	__remote_val := bucket_storage_tally_remote.value()
	__remote_segments_count_val := bucket_storage_tally_remote_segments_count.value()
	__inline_segments_count_val := bucket_storage_tally_inline_segments_count.value()
	__object_count_val := bucket_storage_tally_object_count.value()
	__metadata_size_val := bucket_storage_tally_metadata_size.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_storage_tallies ( bucket_name, project_id, interval_start, inline, remote, remote_segments_count, inline_segments_count, object_count, metadata_size ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __bucket_name_val, __project_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)

	__res, err := obj.driver.Exec(__stmt, __bucket_name_val, __project_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastBucketStorageTally(ctx, __pk)

}

func (obj *sqlite3Impl) Create_StoragenodeStorageTally(ctx context.Context,
	storagenode_storage_tally_node_id StoragenodeStorageTally_NodeId_Field,
	storagenode_storage_tally_interval_end_time StoragenodeStorageTally_IntervalEndTime_Field,
	storagenode_storage_tally_data_total StoragenodeStorageTally_DataTotal_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {
	__node_id_val := storagenode_storage_tally_node_id.value()
	__interval_end_time_val := storagenode_storage_tally_interval_end_time.value()
	__data_total_val := storagenode_storage_tally_data_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO storagenode_storage_tallies ( node_id, interval_end_time, data_total ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __interval_end_time_val, __data_total_val)

	__res, err := obj.driver.Exec(__stmt, __node_id_val, __interval_end_time_val, __data_total_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastStoragenodeStorageTally(ctx, __pk)

}

func (obj *sqlite3Impl) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__publickey_val := certRecord_publickey.value()
	__id_val := certRecord_id.value()
	__update_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO certRecords ( publickey, id, update_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __publickey_val, __id_val, __update_at_val)

	__res, err := obj.driver.Exec(__stmt, __publickey_val, __id_val, __update_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastCertRecord(ctx, __pk)

}

func (obj *sqlite3Impl) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := registration_token_secret.value()
	__owner_id_val := optional.OwnerId.value()
	__project_limit_val := registration_token_project_limit.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO registration_tokens ( secret, owner_id, project_limit, created_at ) VALUES ( ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastRegistrationToken(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ResetPasswordToken(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := reset_password_token_secret.value()
	__owner_id_val := reset_password_token_owner_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO reset_password_tokens ( secret, owner_id, created_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __secret_val, __owner_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastResetPasswordToken(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Offer(ctx context.Context,
	offer_name Offer_Name_Field,
	offer_description Offer_Description_Field,
	offer_award_credit_in_cents Offer_AwardCreditInCents_Field,
	offer_invitee_credit_in_cents Offer_InviteeCreditInCents_Field,
	offer_expires_at Offer_ExpiresAt_Field,
	offer_status Offer_Status_Field,
	offer_type Offer_Type_Field,
	optional Offer_Create_Fields) (
	offer *Offer, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__name_val := offer_name.value()
	__description_val := offer_description.value()
	__award_credit_in_cents_val := offer_award_credit_in_cents.value()
	__invitee_credit_in_cents_val := offer_invitee_credit_in_cents.value()
	__award_credit_duration_days_val := optional.AwardCreditDurationDays.value()
	__invitee_credit_duration_days_val := optional.InviteeCreditDurationDays.value()
	__redeemable_cap_val := optional.RedeemableCap.value()
	__expires_at_val := offer_expires_at.value()
	__created_at_val := __now
	__status_val := offer_status.value()
	__type_val := offer_type.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO offers ( name, description, award_credit_in_cents, invitee_credit_in_cents, award_credit_duration_days, invitee_credit_duration_days, redeemable_cap, expires_at, created_at, status, type ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __description_val, __award_credit_in_cents_val, __invitee_credit_in_cents_val, __award_credit_duration_days_val, __invitee_credit_duration_days_val, __redeemable_cap_val, __expires_at_val, __created_at_val, __status_val, __type_val)

	__res, err := obj.driver.Exec(__stmt, __name_val, __description_val, __award_credit_in_cents_val, __invitee_credit_in_cents_val, __award_credit_duration_days_val, __invitee_credit_duration_days_val, __redeemable_cap_val, __expires_at_val, __created_at_val, __status_val, __type_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastOffer(ctx, __pk)

}

func (obj *sqlite3Impl) Create_UserCredit(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_offer_id UserCredit_OfferId_Field,
	user_credit_credits_earned_in_cents UserCredit_CreditsEarnedInCents_Field,
	user_credit_expires_at UserCredit_ExpiresAt_Field,
	optional UserCredit_Create_Fields) (
	user_credit *UserCredit, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__user_id_val := user_credit_user_id.value()
	__offer_id_val := user_credit_offer_id.value()
	__referred_by_val := optional.ReferredBy.value()
	__credits_earned_in_cents_val := user_credit_credits_earned_in_cents.value()
	__credits_used_in_cents_val := int(0)
	__expires_at_val := user_credit_expires_at.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO user_credits ( user_id, offer_id, referred_by, credits_earned_in_cents, credits_used_in_cents, expires_at, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __user_id_val, __offer_id_val, __referred_by_val, __credits_earned_in_cents_val, __credits_used_in_cents_val, __expires_at_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __user_id_val, __offer_id_val, __referred_by_val, __credits_earned_in_cents_val, __credits_used_in_cents_val, __expires_at_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUserCredit(ctx, __pk)

}

func (obj *sqlite3Impl) Create_BucketMetainfo(ctx context.Context,
	bucket_metainfo_id BucketMetainfo_Id_Field,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	bucket_metainfo_path_cipher BucketMetainfo_PathCipher_Field,
	bucket_metainfo_default_segment_size BucketMetainfo_DefaultSegmentSize_Field,
	bucket_metainfo_default_encryption_cipher_suite BucketMetainfo_DefaultEncryptionCipherSuite_Field,
	bucket_metainfo_default_encryption_block_size BucketMetainfo_DefaultEncryptionBlockSize_Field,
	bucket_metainfo_default_redundancy_algorithm BucketMetainfo_DefaultRedundancyAlgorithm_Field,
	bucket_metainfo_default_redundancy_share_size BucketMetainfo_DefaultRedundancyShareSize_Field,
	bucket_metainfo_default_redundancy_required_shares BucketMetainfo_DefaultRedundancyRequiredShares_Field,
	bucket_metainfo_default_redundancy_repair_shares BucketMetainfo_DefaultRedundancyRepairShares_Field,
	bucket_metainfo_default_redundancy_optimal_shares BucketMetainfo_DefaultRedundancyOptimalShares_Field,
	bucket_metainfo_default_redundancy_total_shares BucketMetainfo_DefaultRedundancyTotalShares_Field,
	optional BucketMetainfo_Create_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := bucket_metainfo_id.value()
	__project_id_val := bucket_metainfo_project_id.value()
	__name_val := bucket_metainfo_name.value()
	__partner_id_val := optional.PartnerId.value()
	__path_cipher_val := bucket_metainfo_path_cipher.value()
	__created_at_val := __now
	__default_segment_size_val := bucket_metainfo_default_segment_size.value()
	__default_encryption_cipher_suite_val := bucket_metainfo_default_encryption_cipher_suite.value()
	__default_encryption_block_size_val := bucket_metainfo_default_encryption_block_size.value()
	__default_redundancy_algorithm_val := bucket_metainfo_default_redundancy_algorithm.value()
	__default_redundancy_share_size_val := bucket_metainfo_default_redundancy_share_size.value()
	__default_redundancy_required_shares_val := bucket_metainfo_default_redundancy_required_shares.value()
	__default_redundancy_repair_shares_val := bucket_metainfo_default_redundancy_repair_shares.value()
	__default_redundancy_optimal_shares_val := bucket_metainfo_default_redundancy_optimal_shares.value()
	__default_redundancy_total_shares_val := bucket_metainfo_default_redundancy_total_shares.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_metainfos ( id, project_id, name, partner_id, path_cipher, created_at, default_segment_size, default_encryption_cipher_suite, default_encryption_block_size, default_redundancy_algorithm, default_redundancy_share_size, default_redundancy_required_shares, default_redundancy_repair_shares, default_redundancy_optimal_shares, default_redundancy_total_shares ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __name_val, __partner_id_val, __path_cipher_val, __created_at_val, __default_segment_size_val, __default_encryption_cipher_suite_val, __default_encryption_block_size_val, __default_redundancy_algorithm_val, __default_redundancy_share_size_val, __default_redundancy_required_shares_val, __default_redundancy_repair_shares_val, __default_redundancy_optimal_shares_val, __default_redundancy_total_shares_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __project_id_val, __name_val, __partner_id_val, __path_cipher_val, __created_at_val, __default_segment_size_val, __default_encryption_cipher_suite_val, __default_encryption_block_size_val, __default_redundancy_algorithm_val, __default_redundancy_share_size_val, __default_redundancy_required_shares_val, __default_redundancy_repair_shares_val, __default_redundancy_optimal_shares_val, __default_redundancy_total_shares_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastBucketMetainfo(ctx, __pk)

}

func (obj *sqlite3Impl) Get_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	value_attribution *ValueAttribution, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT value_attributions.project_id, value_attributions.bucket_name, value_attributions.partner_id, value_attributions.last_updated FROM value_attributions WHERE value_attributions.project_id = ? AND value_attributions.bucket_name = ?")

	var __values []interface{}
	__values = append(__values, value_attribution_project_id.value(), value_attribution_bucket_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	value_attribution = &ValueAttribution{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&value_attribution.ProjectId, &value_attribution.BucketName, &value_attribution.PartnerId, &value_attribution.LastUpdated)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return value_attribution, nil

}

func (obj *sqlite3Impl) Get_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	pending_audits *PendingAudits, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path FROM pending_audits WHERE pending_audits.node_id = ?")

	var __values []interface{}
	__values = append(__values, pending_audits_node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pending_audits = &PendingAudits{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil

}

func (obj *sqlite3Impl) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *sqlite3Impl) Limited_Irreparabledb_By_Segmentpath_Greater_OrderBy_Asc_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath_greater Irreparabledb_Segmentpath_Field,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath > ? ORDER BY irreparabledbs.segmentpath LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath_greater.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		irreparabledb := &Irreparabledb{}
		err = __rows.Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, irreparabledb)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __values []interface{}
	__values = append(__values, accounting_timestamps_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &Value_Row{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&row.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return row, nil

}

func (obj *sqlite3Impl) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *sqlite3Impl) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.start_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_start_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_rollup := &AccountingRollup{}
		err = __rows.Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *sqlite3Impl) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id FROM nodes")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_Row{}
		err = __rows.Scan(&row.Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE nodes.id >= ? ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		node := &Node{}
		err = __rows.Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, node)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_Node_Id_Node_LastNet_Node_Address_Node_Protocol_By_Id_GreaterOrEqual_And_Disqualified_Is_Null_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Id_LastNet_Address_Protocol_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.last_net, nodes.address, nodes.protocol FROM nodes WHERE nodes.id >= ? AND nodes.disqualified is NULL ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_LastNet_Address_Protocol_Row{}
		err = __rows.Scan(&row.Id, &row.LastNet, &row.Address, &row.Protocol)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE users.email = ? AND users.status != 0 LIMIT 2")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	user = &User{}
	err = __rows.Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("User_By_Email_And_Status_Not_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return user, nil

}

func (obj *sqlite3Impl) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) Get_UserPayment_By_UserId(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field) (
	user_payment *UserPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_payments.user_id, user_payments.customer_id, user_payments.created_at FROM user_payments WHERE user_payments.user_id = ?")

	var __values []interface{}
	__values = append(__values, user_payment_user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user_payment = &UserPayment{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user_payment.UserId, &user_payment.CustomerId, &user_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_payment, nil

}

func (obj *sqlite3Impl) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *sqlite3Impl) All_Project(ctx context.Context) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Project_By_CreatedAt_Less_OrderBy_Asc_CreatedAt(ctx context.Context,
	project_created_at_less Project_CreatedAt_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE projects.created_at < ? ORDER BY projects.created_at")

	var __values []interface{}
	__values = append(__values, project_created_at_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects  JOIN project_members ON projects.id = project_members.project_id WHERE project_members.member_id = ? ORDER BY projects.name")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	project_payment *ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project_payment = &ProjectPayment{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil

}

func (obj *sqlite3Impl) Get_ProjectPayment_By_ProjectId_And_IsDefault_Equal_True(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	project_payment *ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.project_id = ? AND project_payments.is_default = 1 LIMIT 2")

	var __values []interface{}
	__values = append(__values, project_payment_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	project_payment = &ProjectPayment{}
	err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("ProjectPayment_By_ProjectId_And_IsDefault_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return project_payment, nil

}

func (obj *sqlite3Impl) All_ProjectPayment_By_ProjectId(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	rows []*ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_payment := &ProjectPayment{}
		err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_payment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_ProjectPayment_By_PayerId(ctx context.Context,
	project_payment_payer_id ProjectPayment_PayerId_Field) (
	rows []*ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.payer_id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_payer_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_payment := &ProjectPayment{}
		err = __rows.Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_payment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_ProjectInvoiceStamp_By_ProjectId_And_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at FROM project_invoice_stamps WHERE project_invoice_stamps.project_id = ? AND project_invoice_stamps.start_date = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, project_invoice_stamp_project_id.value(), project_invoice_stamp_start_date.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	project_invoice_stamp = &ProjectInvoiceStamp{}
	err = __rows.Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("ProjectInvoiceStamp_By_ProjectId_And_StartDate")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return project_invoice_stamp, nil

}

func (obj *sqlite3Impl) All_ProjectInvoiceStamp_By_ProjectId_OrderBy_Desc_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field) (
	rows []*ProjectInvoiceStamp, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at FROM project_invoice_stamps WHERE project_invoice_stamps.project_id = ? ORDER BY project_invoice_stamps.start_date DESC")

	var __values []interface{}
	__values = append(__values, project_invoice_stamp_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_invoice_stamp := &ProjectInvoiceStamp{}
		err = __rows.Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_invoice_stamp)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.member_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.project_id = ? LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, project_member_project_id.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) Get_ApiKey_By_Head(ctx context.Context,
	api_key_head ApiKey_Head_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.head = ?")

	var __values []interface{}
	__values = append(__values, api_key_head.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.project_id = ? ORDER BY api_keys.name")

	var __values []interface{}
	__values = append(__values, api_key_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		api_key := &ApiKey{}
		err = __rows.Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, api_key)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *sqlite3Impl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time DESC LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE serial_numbers.serial_number = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, serial_number_serial_number.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	serial_number = &SerialNumber{}
	err = __rows.Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("SerialNumber_By_SerialNumber")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return serial_number, nil

}

func (obj *sqlite3Impl) Find_BucketBandwidthRollup_By_BucketName_And_ProjectId_And_IntervalStart_And_Action(ctx context.Context,
	bucket_bandwidth_rollup_bucket_name BucketBandwidthRollup_BucketName_Field,
	bucket_bandwidth_rollup_project_id BucketBandwidthRollup_ProjectId_Field,
	bucket_bandwidth_rollup_interval_start BucketBandwidthRollup_IntervalStart_Field,
	bucket_bandwidth_rollup_action BucketBandwidthRollup_Action_Field) (
	bucket_bandwidth_rollup *BucketBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_bandwidth_rollups.bucket_name, bucket_bandwidth_rollups.project_id, bucket_bandwidth_rollups.interval_start, bucket_bandwidth_rollups.interval_seconds, bucket_bandwidth_rollups.action, bucket_bandwidth_rollups.inline, bucket_bandwidth_rollups.allocated, bucket_bandwidth_rollups.settled FROM bucket_bandwidth_rollups WHERE bucket_bandwidth_rollups.bucket_name = ? AND bucket_bandwidth_rollups.project_id = ? AND bucket_bandwidth_rollups.interval_start = ? AND bucket_bandwidth_rollups.action = ?")

	var __values []interface{}
	__values = append(__values, bucket_bandwidth_rollup_bucket_name.value(), bucket_bandwidth_rollup_project_id.value(), bucket_bandwidth_rollup_interval_start.value(), bucket_bandwidth_rollup_action.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_bandwidth_rollup = &BucketBandwidthRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_bandwidth_rollup.BucketName, &bucket_bandwidth_rollup.ProjectId, &bucket_bandwidth_rollup.IntervalStart, &bucket_bandwidth_rollup.IntervalSeconds, &bucket_bandwidth_rollup.Action, &bucket_bandwidth_rollup.Inline, &bucket_bandwidth_rollup.Allocated, &bucket_bandwidth_rollup.Settled)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_bandwidth_rollup, nil

}

func (obj *sqlite3Impl) First_BucketStorageTally_By_ProjectId_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE bucket_storage_tallies.project_id = ? ORDER BY bucket_storage_tallies.interval_start DESC LIMIT 1 OFFSET 0")

	var __values []interface{}
	__values = append(__values, bucket_storage_tally_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	bucket_storage_tally = &BucketStorageTally{}
	err = __rows.Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return bucket_storage_tally, nil

}

func (obj *sqlite3Impl) All_BucketStorageTally_By_ProjectId_And_BucketName_And_IntervalStart_GreaterOrEqual_And_IntervalStart_LessOrEqual_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_interval_start_greater_or_equal BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_interval_start_less_or_equal BucketStorageTally_IntervalStart_Field) (
	rows []*BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE bucket_storage_tallies.project_id = ? AND bucket_storage_tallies.bucket_name = ? AND bucket_storage_tallies.interval_start >= ? AND bucket_storage_tallies.interval_start <= ? ORDER BY bucket_storage_tallies.interval_start DESC")

	var __values []interface{}
	__values = append(__values, bucket_storage_tally_project_id.value(), bucket_storage_tally_bucket_name.value(), bucket_storage_tally_interval_start_greater_or_equal.value(), bucket_storage_tally_interval_start_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_storage_tally := &BucketStorageTally{}
		err = __rows.Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_StoragenodeBandwidthRollup_By_StoragenodeId_And_IntervalStart_And_Action(ctx context.Context,
	storagenode_bandwidth_rollup_storagenode_id StoragenodeBandwidthRollup_StoragenodeId_Field,
	storagenode_bandwidth_rollup_interval_start StoragenodeBandwidthRollup_IntervalStart_Field,
	storagenode_bandwidth_rollup_action StoragenodeBandwidthRollup_Action_Field) (
	storagenode_bandwidth_rollup *StoragenodeBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_bandwidth_rollups.storagenode_id, storagenode_bandwidth_rollups.interval_start, storagenode_bandwidth_rollups.interval_seconds, storagenode_bandwidth_rollups.action, storagenode_bandwidth_rollups.allocated, storagenode_bandwidth_rollups.settled FROM storagenode_bandwidth_rollups WHERE storagenode_bandwidth_rollups.storagenode_id = ? AND storagenode_bandwidth_rollups.interval_start = ? AND storagenode_bandwidth_rollups.action = ?")

	var __values []interface{}
	__values = append(__values, storagenode_bandwidth_rollup_storagenode_id.value(), storagenode_bandwidth_rollup_interval_start.value(), storagenode_bandwidth_rollup_action.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	storagenode_bandwidth_rollup = &StoragenodeBandwidthRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&storagenode_bandwidth_rollup.StoragenodeId, &storagenode_bandwidth_rollup.IntervalStart, &storagenode_bandwidth_rollup.IntervalSeconds, &storagenode_bandwidth_rollup.Action, &storagenode_bandwidth_rollup.Allocated, &storagenode_bandwidth_rollup.Settled)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_bandwidth_rollup, nil

}

func (obj *sqlite3Impl) All_StoragenodeBandwidthRollup_By_IntervalStart_GreaterOrEqual(ctx context.Context,
	storagenode_bandwidth_rollup_interval_start_greater_or_equal StoragenodeBandwidthRollup_IntervalStart_Field) (
	rows []*StoragenodeBandwidthRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_bandwidth_rollups.storagenode_id, storagenode_bandwidth_rollups.interval_start, storagenode_bandwidth_rollups.interval_seconds, storagenode_bandwidth_rollups.action, storagenode_bandwidth_rollups.allocated, storagenode_bandwidth_rollups.settled FROM storagenode_bandwidth_rollups WHERE storagenode_bandwidth_rollups.interval_start >= ?")

	var __values []interface{}
	__values = append(__values, storagenode_bandwidth_rollup_interval_start_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_bandwidth_rollup := &StoragenodeBandwidthRollup{}
		err = __rows.Scan(&storagenode_bandwidth_rollup.StoragenodeId, &storagenode_bandwidth_rollup.IntervalStart, &storagenode_bandwidth_rollup.IntervalSeconds, &storagenode_bandwidth_rollup.Action, &storagenode_bandwidth_rollup.Allocated, &storagenode_bandwidth_rollup.Settled)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_bandwidth_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.id = ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	storagenode_storage_tally = &StoragenodeStorageTally{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_storage_tally, nil

}

func (obj *sqlite3Impl) All_StoragenodeStorageTally(ctx context.Context) (
	rows []*StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_storage_tally := &StoragenodeStorageTally{}
		err = __rows.Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_StoragenodeStorageTally_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	storagenode_storage_tally_interval_end_time_greater_or_equal StoragenodeStorageTally_IntervalEndTime_Field) (
	rows []*StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.interval_end_time >= ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_interval_end_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		storagenode_storage_tally := &StoragenodeStorageTally{}
		err = __rows.Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, storagenode_storage_tally)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *sqlite3Impl) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, registration_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *sqlite3Impl) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "registration_tokens.owner_id", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !registration_token_owner_id.isnull() {
		__cond_0.Null = false
		__values = append(__values, registration_token_owner_id.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *sqlite3Impl) Get_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at FROM reset_password_tokens WHERE reset_password_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *sqlite3Impl) Get_ResetPasswordToken_By_OwnerId(ctx context.Context,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at FROM reset_password_tokens WHERE reset_password_tokens.owner_id = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_owner_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *sqlite3Impl) Get_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field) (
	offer *Offer, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers WHERE offers.id = ?")

	var __values []interface{}
	__values = append(__values, offer_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	offer = &Offer{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil

}

func (obj *sqlite3Impl) All_Offer_OrderBy_Asc_Id(ctx context.Context) (
	rows []*Offer, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers ORDER BY offers.id")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		offer := &Offer{}
		err = __rows.Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, offer)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_UserCredit_By_UserId_And_ExpiresAt_Greater_And_CreditsUsedInCents_Less_CreditsEarnedInCents_OrderBy_Asc_ExpiresAt(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_expires_at_greater UserCredit_ExpiresAt_Field) (
	rows []*UserCredit, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_credits.id, user_credits.user_id, user_credits.offer_id, user_credits.referred_by, user_credits.credits_earned_in_cents, user_credits.credits_used_in_cents, user_credits.expires_at, user_credits.created_at FROM user_credits WHERE user_credits.user_id = ? AND user_credits.expires_at > ? AND user_credits.credits_used_in_cents < user_credits.credits_earned_in_cents ORDER BY user_credits.expires_at")

	var __values []interface{}
	__values = append(__values, user_credit_user_id.value(), user_credit_expires_at_greater.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		user_credit := &UserCredit{}
		err = __rows.Scan(&user_credit.Id, &user_credit.UserId, &user_credit.OfferId, &user_credit.ReferredBy, &user_credit.CreditsEarnedInCents, &user_credit.CreditsUsedInCents, &user_credit.ExpiresAt, &user_credit.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, user_credit)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Count_UserCredit_By_ReferredBy(ctx context.Context,
	user_credit_referred_by UserCredit_ReferredBy_Field) (
	count int64, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "user_credits.referred_by", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT COUNT(*) FROM user_credits WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !user_credit_referred_by.isnull() {
		__cond_0.Null = false
		__values = append(__values, user_credit_referred_by.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRow(__stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Get_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	bucket_metainfo *BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_metainfo = &BucketMetainfo{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil

}

func (obj *sqlite3Impl) Limited_BucketMetainfo_By_ProjectId_And_Name_GreaterOrEqual_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater_or_equal BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name >= ? ORDER BY bucket_metainfos.name LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_metainfo := &BucketMetainfo{}
		err = __rows.Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_metainfo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_BucketMetainfo_By_ProjectId_And_Name_Greater_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name > ? ORDER BY bucket_metainfos.name LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name_greater.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_metainfo := &BucketMetainfo{}
		err = __rows.Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_metainfo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Update_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	update PendingAudits_Update_Fields) (
	pending_audits *PendingAudits, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE pending_audits SET "), __sets, __sqlbundle_Literal(" WHERE pending_audits.node_id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.ReverifyCount._set {
		__values = append(__values, update.ReverifyCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("reverify_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, pending_audits_node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pending_audits = &PendingAudits{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path FROM pending_audits WHERE pending_audits.node_id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil
}

func (obj *sqlite3Impl) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE irreparabledbs SET "), __sets, __sqlbundle_Literal(" WHERE irreparabledbs.segmentpath = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Segmentdetail._set {
		__values = append(__values, update.Segmentdetail.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("segmentdetail = ?"))
	}

	if update.PiecesLostCount._set {
		__values = append(__values, update.PiecesLostCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("pieces_lost_count = ?"))
	}

	if update.SegDamagedUnixSec._set {
		__values = append(__values, update.SegDamagedUnixSec.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("seg_damaged_unix_sec = ?"))
	}

	if update.RepairAttemptCount._set {
		__values = append(__values, update.RepairAttemptCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("repair_attempt_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, irreparabledb_segmentpath.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil
}

func (obj *sqlite3Impl) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE accounting_timestamps SET "), __sets, __sqlbundle_Literal(" WHERE accounting_timestamps.name = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Value._set {
		__values = append(__values, update.Value.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, accounting_timestamps_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_timestamps = &AccountingTimestamps{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT accounting_timestamps.name, accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil
}

func (obj *sqlite3Impl) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE nodes SET "), __sets, __sqlbundle_Literal(" WHERE nodes.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Address._set {
		__values = append(__values, update.Address.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("address = ?"))
	}

	if update.LastNet._set {
		__values = append(__values, update.LastNet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_net = ?"))
	}

	if update.Protocol._set {
		__values = append(__values, update.Protocol.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("protocol = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.Wallet._set {
		__values = append(__values, update.Wallet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("wallet = ?"))
	}

	if update.FreeBandwidth._set {
		__values = append(__values, update.FreeBandwidth.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_bandwidth = ?"))
	}

	if update.FreeDisk._set {
		__values = append(__values, update.FreeDisk.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_disk = ?"))
	}

	if update.Major._set {
		__values = append(__values, update.Major.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("major = ?"))
	}

	if update.Minor._set {
		__values = append(__values, update.Minor.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("minor = ?"))
	}

	if update.Patch._set {
		__values = append(__values, update.Patch.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("patch = ?"))
	}

	if update.Hash._set {
		__values = append(__values, update.Hash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("hash = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Release._set {
		__values = append(__values, update.Release.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("release = ?"))
	}

	if update.Latency90._set {
		__values = append(__values, update.Latency90.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("latency_90 = ?"))
	}

	if update.AuditSuccessCount._set {
		__values = append(__values, update.AuditSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_count = ?"))
	}

	if update.TotalAuditCount._set {
		__values = append(__values, update.TotalAuditCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_audit_count = ?"))
	}

	if update.UptimeSuccessCount._set {
		__values = append(__values, update.UptimeSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_success_count = ?"))
	}

	if update.TotalUptimeCount._set {
		__values = append(__values, update.TotalUptimeCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_uptime_count = ?"))
	}

	if update.LastContactSuccess._set {
		__values = append(__values, update.LastContactSuccess.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_success = ?"))
	}

	if update.LastContactFailure._set {
		__values = append(__values, update.LastContactFailure.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_failure = ?"))
	}

	if update.Contained._set {
		__values = append(__values, update.Contained.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("contained = ?"))
	}

	if update.Disqualified._set {
		__values = append(__values, update.Disqualified.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("disqualified = ?"))
	}

	if update.AuditReputationAlpha._set {
		__values = append(__values, update.AuditReputationAlpha.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_reputation_alpha = ?"))
	}

	if update.AuditReputationBeta._set {
		__values = append(__values, update.AuditReputationBeta.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_reputation_beta = ?"))
	}

	if update.UptimeReputationAlpha._set {
		__values = append(__values, update.UptimeReputationAlpha.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_reputation_alpha = ?"))
	}

	if update.UptimeReputationBeta._set {
		__values = append(__values, update.UptimeReputationBeta.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_reputation_beta = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE nodes.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil
}

func (obj *sqlite3Impl) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE users SET "), __sets, __sqlbundle_Literal(" WHERE users.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.FullName._set {
		__values = append(__values, update.FullName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("full_name = ?"))
	}

	if update.ShortName._set {
		__values = append(__values, update.ShortName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("short_name = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, user_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE users.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil
}

func (obj *sqlite3Impl) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE projects SET "), __sets, __sqlbundle_Literal(" WHERE projects.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.UsageLimit._set {
		__values = append(__values, update.UsageLimit.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("usage_limit = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE projects.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil
}

func (obj *sqlite3Impl) Update_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	update ProjectPayment_Update_Fields) (
	project_payment *ProjectPayment, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE project_payments SET "), __sets, __sqlbundle_Literal(" WHERE project_payments.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.IsDefault._set {
		__values = append(__values, update.IsDefault.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("is_default = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_payment_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project_payment = &ProjectPayment{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE project_payments.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil
}

func (obj *sqlite3Impl) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE api_keys SET "), __sets, __sqlbundle_Literal(" WHERE api_keys.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, api_key_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil
}

func (obj *sqlite3Impl) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE certRecords SET "), __sets, __sqlbundle_Literal(" WHERE certRecords.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("update_at = ?"))

	__args = append(__args, certRecord_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil
}

func (obj *sqlite3Impl) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE registration_tokens SET "), __sets, __sqlbundle_Literal(" WHERE registration_tokens.secret = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.OwnerId._set {
		__values = append(__values, update.OwnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("owner_id = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, registration_token_secret.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil
}

func (obj *sqlite3Impl) Update_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field,
	update Offer_Update_Fields) (
	offer *Offer, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE offers SET "), __sets, __sqlbundle_Literal(" WHERE offers.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.AwardCreditInCents._set {
		__values = append(__values, update.AwardCreditInCents.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("award_credit_in_cents = ?"))
	}

	if update.InviteeCreditInCents._set {
		__values = append(__values, update.InviteeCreditInCents.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("invitee_credit_in_cents = ?"))
	}

	if update.AwardCreditDurationDays._set {
		__values = append(__values, update.AwardCreditDurationDays.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("award_credit_duration_days = ?"))
	}

	if update.InviteeCreditDurationDays._set {
		__values = append(__values, update.InviteeCreditDurationDays.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("invitee_credit_duration_days = ?"))
	}

	if update.RedeemableCap._set {
		__values = append(__values, update.RedeemableCap.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("redeemable_cap = ?"))
	}

	if update.ExpiresAt._set {
		__values = append(__values, update.ExpiresAt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("expires_at = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, offer_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	offer = &Offer{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers WHERE offers.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil
}

func (obj *sqlite3Impl) Update_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	update BucketMetainfo_Update_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bucket_metainfos SET "), __sets, __sqlbundle_Literal(" WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.PartnerId._set {
		__values = append(__values, update.PartnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("partner_id = ?"))
	}

	if update.DefaultSegmentSize._set {
		__values = append(__values, update.DefaultSegmentSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_segment_size = ?"))
	}

	if update.DefaultEncryptionCipherSuite._set {
		__values = append(__values, update.DefaultEncryptionCipherSuite.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_encryption_cipher_suite = ?"))
	}

	if update.DefaultEncryptionBlockSize._set {
		__values = append(__values, update.DefaultEncryptionBlockSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_encryption_block_size = ?"))
	}

	if update.DefaultRedundancyAlgorithm._set {
		__values = append(__values, update.DefaultRedundancyAlgorithm.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_algorithm = ?"))
	}

	if update.DefaultRedundancyShareSize._set {
		__values = append(__values, update.DefaultRedundancyShareSize.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_share_size = ?"))
	}

	if update.DefaultRedundancyRequiredShares._set {
		__values = append(__values, update.DefaultRedundancyRequiredShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_required_shares = ?"))
	}

	if update.DefaultRedundancyRepairShares._set {
		__values = append(__values, update.DefaultRedundancyRepairShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_repair_shares = ?"))
	}

	if update.DefaultRedundancyOptimalShares._set {
		__values = append(__values, update.DefaultRedundancyOptimalShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_optimal_shares = ?"))
	}

	if update.DefaultRedundancyTotalShares._set {
		__values = append(__values, update.DefaultRedundancyTotalShares.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("default_redundancy_total_shares = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_metainfo = &BucketMetainfo{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil
}

func (obj *sqlite3Impl) Delete_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM value_attributions WHERE value_attributions.project_id = ? AND value_attributions.bucket_name = ?")

	var __values []interface{}
	__values = append(__values, value_attribution_project_id.value(), value_attribution_bucket_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM pending_audits WHERE pending_audits.node_id = ?")

	var __values []interface{}
	__values = append(__values, pending_audits_node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_payments WHERE project_payments.id = ?")

	var __values []interface{}
	__values = append(__values, project_payment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_members WHERE project_members.member_id = ? AND project_members.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value(), project_member_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM serial_numbers WHERE serial_numbers.expires_at <= ?")

	var __values []interface{}
	__values = append(__values, serial_number_expires_at_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Delete_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM storagenode_storage_tallies WHERE storagenode_storage_tallies.id = ?")

	var __values []interface{}
	__values = append(__values, storagenode_storage_tally_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM reset_password_tokens WHERE reset_password_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, reset_password_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_metainfos WHERE bucket_metainfos.project_id = ? AND bucket_metainfos.name = ?")

	var __values []interface{}
	__values = append(__values, bucket_metainfo_project_id.value(), bucket_metainfo_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) getLastValueAttribution(ctx context.Context,
	pk int64) (
	value_attribution *ValueAttribution, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT value_attributions.project_id, value_attributions.bucket_name, value_attributions.partner_id, value_attributions.last_updated FROM value_attributions WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	value_attribution = &ValueAttribution{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&value_attribution.ProjectId, &value_attribution.BucketName, &value_attribution.PartnerId, &value_attribution.LastUpdated)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return value_attribution, nil

}

func (obj *sqlite3Impl) getLastPendingAudits(ctx context.Context,
	pk int64) (
	pending_audits *PendingAudits, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT pending_audits.node_id, pending_audits.piece_id, pending_audits.stripe_index, pending_audits.share_size, pending_audits.expected_share_hash, pending_audits.reverify_count, pending_audits.path FROM pending_audits WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	pending_audits = &PendingAudits{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&pending_audits.NodeId, &pending_audits.PieceId, &pending_audits.StripeIndex, &pending_audits.ShareSize, &pending_audits.ExpectedShareHash, &pending_audits.ReverifyCount, &pending_audits.Path)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pending_audits, nil

}

func (obj *sqlite3Impl) getLastIrreparabledb(ctx context.Context,
	pk int64) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *sqlite3Impl) getLastAccountingTimestamps(ctx context.Context,
	pk int64) (
	accounting_timestamps *AccountingTimestamps, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.name, accounting_timestamps.value FROM accounting_timestamps WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil

}

func (obj *sqlite3Impl) getLastAccountingRollup(ctx context.Context,
	pk int64) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *sqlite3Impl) getLastNode(ctx context.Context,
	pk int64) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.last_net, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.major, nodes.minor, nodes.patch, nodes.hash, nodes.timestamp, nodes.release, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.uptime_success_count, nodes.total_uptime_count, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure, nodes.contained, nodes.disqualified, nodes.audit_reputation_alpha, nodes.audit_reputation_beta, nodes.uptime_reputation_alpha, nodes.uptime_reputation_beta FROM nodes WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&node.Id, &node.Address, &node.LastNet, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Major, &node.Minor, &node.Patch, &node.Hash, &node.Timestamp, &node.Release, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure, &node.Contained, &node.Disqualified, &node.AuditReputationAlpha, &node.AuditReputationBeta, &node.UptimeReputationAlpha, &node.UptimeReputationBeta)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *sqlite3Impl) getLastUser(ctx context.Context,
	pk int64) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.email, users.full_name, users.short_name, users.password_hash, users.status, users.partner_id, users.created_at FROM users WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&user.Id, &user.Email, &user.FullName, &user.ShortName, &user.PasswordHash, &user.Status, &user.PartnerId, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) getLastUserPayment(ctx context.Context,
	pk int64) (
	user_payment *UserPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_payments.user_id, user_payments.customer_id, user_payments.created_at FROM user_payments WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	user_payment = &UserPayment{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&user_payment.UserId, &user_payment.CustomerId, &user_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_payment, nil

}

func (obj *sqlite3Impl) getLastProject(ctx context.Context,
	pk int64) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.usage_limit, projects.partner_id, projects.created_at FROM projects WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project.Id, &project.Name, &project.Description, &project.UsageLimit, &project.PartnerId, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *sqlite3Impl) getLastProjectPayment(ctx context.Context,
	pk int64) (
	project_payment *ProjectPayment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_payments.id, project_payments.project_id, project_payments.payer_id, project_payments.payment_method_id, project_payments.is_default, project_payments.created_at FROM project_payments WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project_payment = &ProjectPayment{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project_payment.Id, &project_payment.ProjectId, &project_payment.PayerId, &project_payment.PaymentMethodId, &project_payment.IsDefault, &project_payment.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_payment, nil

}

func (obj *sqlite3Impl) getLastProjectInvoiceStamp(ctx context.Context,
	pk int64) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_invoice_stamps.project_id, project_invoice_stamps.invoice_id, project_invoice_stamps.start_date, project_invoice_stamps.end_date, project_invoice_stamps.created_at FROM project_invoice_stamps WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project_invoice_stamp = &ProjectInvoiceStamp{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project_invoice_stamp.ProjectId, &project_invoice_stamp.InvoiceId, &project_invoice_stamp.StartDate, &project_invoice_stamp.EndDate, &project_invoice_stamp.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_invoice_stamp, nil

}

func (obj *sqlite3Impl) getLastProjectMember(ctx context.Context,
	pk int64) (
	project_member *ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project_member = &ProjectMember{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_member, nil

}

func (obj *sqlite3Impl) getLastApiKey(ctx context.Context,
	pk int64) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.head, api_keys.name, api_keys.secret, api_keys.partner_id, api_keys.created_at FROM api_keys WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Head, &api_key.Name, &api_key.Secret, &api_key.PartnerId, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) getLastBucketUsage(ctx context.Context,
	pk int64) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *sqlite3Impl) getLastSerialNumber(ctx context.Context,
	pk int64) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	serial_number = &SerialNumber{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return serial_number, nil

}

func (obj *sqlite3Impl) getLastUsedSerial(ctx context.Context,
	pk int64) (
	used_serial *UsedSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT used_serials.serial_number_id, used_serials.storage_node_id FROM used_serials WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	used_serial = &UsedSerial{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&used_serial.SerialNumberId, &used_serial.StorageNodeId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return used_serial, nil

}

func (obj *sqlite3Impl) getLastBucketStorageTally(ctx context.Context,
	pk int64) (
	bucket_storage_tally *BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_name, bucket_storage_tallies.project_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	bucket_storage_tally = &BucketStorageTally{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&bucket_storage_tally.BucketName, &bucket_storage_tally.ProjectId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_storage_tally, nil

}

func (obj *sqlite3Impl) getLastStoragenodeStorageTally(ctx context.Context,
	pk int64) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT storagenode_storage_tallies.id, storagenode_storage_tallies.node_id, storagenode_storage_tallies.interval_end_time, storagenode_storage_tallies.data_total FROM storagenode_storage_tallies WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	storagenode_storage_tally = &StoragenodeStorageTally{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&storagenode_storage_tally.Id, &storagenode_storage_tally.NodeId, &storagenode_storage_tally.IntervalEndTime, &storagenode_storage_tally.DataTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return storagenode_storage_tally, nil

}

func (obj *sqlite3Impl) getLastCertRecord(ctx context.Context,
	pk int64) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *sqlite3Impl) getLastRegistrationToken(ctx context.Context,
	pk int64) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *sqlite3Impl) getLastResetPasswordToken(ctx context.Context,
	pk int64) (
	reset_password_token *ResetPasswordToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT reset_password_tokens.secret, reset_password_tokens.owner_id, reset_password_tokens.created_at FROM reset_password_tokens WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	reset_password_token = &ResetPasswordToken{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&reset_password_token.Secret, &reset_password_token.OwnerId, &reset_password_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return reset_password_token, nil

}

func (obj *sqlite3Impl) getLastOffer(ctx context.Context,
	pk int64) (
	offer *Offer, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT offers.id, offers.name, offers.description, offers.award_credit_in_cents, offers.invitee_credit_in_cents, offers.award_credit_duration_days, offers.invitee_credit_duration_days, offers.redeemable_cap, offers.expires_at, offers.created_at, offers.status, offers.type FROM offers WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	offer = &Offer{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&offer.Id, &offer.Name, &offer.Description, &offer.AwardCreditInCents, &offer.InviteeCreditInCents, &offer.AwardCreditDurationDays, &offer.InviteeCreditDurationDays, &offer.RedeemableCap, &offer.ExpiresAt, &offer.CreatedAt, &offer.Status, &offer.Type)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return offer, nil

}

func (obj *sqlite3Impl) getLastUserCredit(ctx context.Context,
	pk int64) (
	user_credit *UserCredit, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT user_credits.id, user_credits.user_id, user_credits.offer_id, user_credits.referred_by, user_credits.credits_earned_in_cents, user_credits.credits_used_in_cents, user_credits.expires_at, user_credits.created_at FROM user_credits WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	user_credit = &UserCredit{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&user_credit.Id, &user_credit.UserId, &user_credit.OfferId, &user_credit.ReferredBy, &user_credit.CreditsEarnedInCents, &user_credit.CreditsUsedInCents, &user_credit.ExpiresAt, &user_credit.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user_credit, nil

}

func (obj *sqlite3Impl) getLastBucketMetainfo(ctx context.Context,
	pk int64) (
	bucket_metainfo *BucketMetainfo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_metainfos.id, bucket_metainfos.project_id, bucket_metainfos.name, bucket_metainfos.partner_id, bucket_metainfos.path_cipher, bucket_metainfos.created_at, bucket_metainfos.default_segment_size, bucket_metainfos.default_encryption_cipher_suite, bucket_metainfos.default_encryption_block_size, bucket_metainfos.default_redundancy_algorithm, bucket_metainfos.default_redundancy_share_size, bucket_metainfos.default_redundancy_required_shares, bucket_metainfos.default_redundancy_repair_shares, bucket_metainfos.default_redundancy_optimal_shares, bucket_metainfos.default_redundancy_total_shares FROM bucket_metainfos WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	bucket_metainfo = &BucketMetainfo{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&bucket_metainfo.Id, &bucket_metainfo.ProjectId, &bucket_metainfo.Name, &bucket_metainfo.PartnerId, &bucket_metainfo.PathCipher, &bucket_metainfo.CreatedAt, &bucket_metainfo.DefaultSegmentSize, &bucket_metainfo.DefaultEncryptionCipherSuite, &bucket_metainfo.DefaultEncryptionBlockSize, &bucket_metainfo.DefaultRedundancyAlgorithm, &bucket_metainfo.DefaultRedundancyShareSize, &bucket_metainfo.DefaultRedundancyRequiredShares, &bucket_metainfo.DefaultRedundancyRepairShares, &bucket_metainfo.DefaultRedundancyOptimalShares, &bucket_metainfo.DefaultRedundancyTotalShares)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_metainfo, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM project_payments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM user_payments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM user_credits;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM used_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_members;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_invoice_stamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_metainfos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM api_keys;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM value_attributions;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM serial_numbers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM reset_password_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM registration_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM projects;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM pending_audits;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM offers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM nodes;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM irreparabledbs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM injuredsegments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM certRecords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_usages;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx *sql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx, accounting_rollup_start_time_greater_or_equal)
}

func (rx *Rx) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx, api_key_project_id)
}

func (rx *Rx) All_BucketStorageTally_By_ProjectId_And_BucketName_And_IntervalStart_GreaterOrEqual_And_IntervalStart_LessOrEqual_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_interval_start_greater_or_equal BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_interval_start_less_or_equal BucketStorageTally_IntervalStart_Field) (
	rows []*BucketStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_BucketStorageTally_By_ProjectId_And_BucketName_And_IntervalStart_GreaterOrEqual_And_IntervalStart_LessOrEqual_OrderBy_Desc_IntervalStart(ctx, bucket_storage_tally_project_id, bucket_storage_tally_bucket_name, bucket_storage_tally_interval_start_greater_or_equal, bucket_storage_tally_interval_start_less_or_equal)
}

func (rx *Rx) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Node_Id(ctx)
}

func (rx *Rx) All_Offer_OrderBy_Asc_Id(ctx context.Context) (
	rows []*Offer, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Offer_OrderBy_Asc_Id(ctx)
}

func (rx *Rx) All_Project(ctx context.Context) (
	rows []*Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Project(ctx)
}

func (rx *Rx) All_ProjectInvoiceStamp_By_ProjectId_OrderBy_Desc_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field) (
	rows []*ProjectInvoiceStamp, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ProjectInvoiceStamp_By_ProjectId_OrderBy_Desc_StartDate(ctx, project_invoice_stamp_project_id)
}

func (rx *Rx) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ProjectMember_By_MemberId(ctx, project_member_member_id)
}

func (rx *Rx) All_ProjectPayment_By_PayerId(ctx context.Context,
	project_payment_payer_id ProjectPayment_PayerId_Field) (
	rows []*ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ProjectPayment_By_PayerId(ctx, project_payment_payer_id)
}

func (rx *Rx) All_ProjectPayment_By_ProjectId(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	rows []*ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ProjectPayment_By_ProjectId(ctx, project_payment_project_id)
}

func (rx *Rx) All_Project_By_CreatedAt_Less_OrderBy_Asc_CreatedAt(ctx context.Context,
	project_created_at_less Project_CreatedAt_Field) (
	rows []*Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Project_By_CreatedAt_Less_OrderBy_Asc_CreatedAt(ctx, project_created_at_less)
}

func (rx *Rx) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx, project_member_member_id)
}

func (rx *Rx) All_StoragenodeBandwidthRollup_By_IntervalStart_GreaterOrEqual(ctx context.Context,
	storagenode_bandwidth_rollup_interval_start_greater_or_equal StoragenodeBandwidthRollup_IntervalStart_Field) (
	rows []*StoragenodeBandwidthRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_StoragenodeBandwidthRollup_By_IntervalStart_GreaterOrEqual(ctx, storagenode_bandwidth_rollup_interval_start_greater_or_equal)
}

func (rx *Rx) All_StoragenodeStorageTally(ctx context.Context) (
	rows []*StoragenodeStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_StoragenodeStorageTally(ctx)
}

func (rx *Rx) All_StoragenodeStorageTally_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	storagenode_storage_tally_interval_end_time_greater_or_equal StoragenodeStorageTally_IntervalEndTime_Field) (
	rows []*StoragenodeStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_StoragenodeStorageTally_By_IntervalEndTime_GreaterOrEqual(ctx, storagenode_storage_tally_interval_end_time_greater_or_equal)
}

func (rx *Rx) All_UserCredit_By_UserId_And_ExpiresAt_Greater_And_CreditsUsedInCents_Less_CreditsEarnedInCents_OrderBy_Asc_ExpiresAt(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_expires_at_greater UserCredit_ExpiresAt_Field) (
	rows []*UserCredit, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_UserCredit_By_UserId_And_ExpiresAt_Greater_And_CreditsUsedInCents_Less_CreditsEarnedInCents_OrderBy_Asc_ExpiresAt(ctx, user_credit_user_id, user_credit_expires_at_greater)
}

func (rx *Rx) Count_UserCredit_By_ReferredBy(ctx context.Context,
	user_credit_referred_by UserCredit_ReferredBy_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_UserCredit_By_ReferredBy(ctx, user_credit_referred_by)
}

func (rx *Rx) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_AccountingRollup(ctx, accounting_rollup_node_id, accounting_rollup_start_time, accounting_rollup_put_total, accounting_rollup_get_total, accounting_rollup_get_audit_total, accounting_rollup_get_repair_total, accounting_rollup_put_repair_total, accounting_rollup_at_rest_total)

}

func (rx *Rx) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_AccountingTimestamps(ctx, accounting_timestamps_name, accounting_timestamps_value)

}

func (rx *Rx) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_head ApiKey_Head_Field,
	api_key_name ApiKey_Name_Field,
	api_key_secret ApiKey_Secret_Field,
	optional ApiKey_Create_Fields) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ApiKey(ctx, api_key_id, api_key_project_id, api_key_head, api_key_name, api_key_secret, optional)

}

func (rx *Rx) Create_BucketMetainfo(ctx context.Context,
	bucket_metainfo_id BucketMetainfo_Id_Field,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	bucket_metainfo_path_cipher BucketMetainfo_PathCipher_Field,
	bucket_metainfo_default_segment_size BucketMetainfo_DefaultSegmentSize_Field,
	bucket_metainfo_default_encryption_cipher_suite BucketMetainfo_DefaultEncryptionCipherSuite_Field,
	bucket_metainfo_default_encryption_block_size BucketMetainfo_DefaultEncryptionBlockSize_Field,
	bucket_metainfo_default_redundancy_algorithm BucketMetainfo_DefaultRedundancyAlgorithm_Field,
	bucket_metainfo_default_redundancy_share_size BucketMetainfo_DefaultRedundancyShareSize_Field,
	bucket_metainfo_default_redundancy_required_shares BucketMetainfo_DefaultRedundancyRequiredShares_Field,
	bucket_metainfo_default_redundancy_repair_shares BucketMetainfo_DefaultRedundancyRepairShares_Field,
	bucket_metainfo_default_redundancy_optimal_shares BucketMetainfo_DefaultRedundancyOptimalShares_Field,
	bucket_metainfo_default_redundancy_total_shares BucketMetainfo_DefaultRedundancyTotalShares_Field,
	optional BucketMetainfo_Create_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_BucketMetainfo(ctx, bucket_metainfo_id, bucket_metainfo_project_id, bucket_metainfo_name, bucket_metainfo_path_cipher, bucket_metainfo_default_segment_size, bucket_metainfo_default_encryption_cipher_suite, bucket_metainfo_default_encryption_block_size, bucket_metainfo_default_redundancy_algorithm, bucket_metainfo_default_redundancy_share_size, bucket_metainfo_default_redundancy_required_shares, bucket_metainfo_default_redundancy_repair_shares, bucket_metainfo_default_redundancy_optimal_shares, bucket_metainfo_default_redundancy_total_shares, optional)

}

func (rx *Rx) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_BucketStorageTally(ctx, bucket_storage_tally_bucket_name, bucket_storage_tally_project_id, bucket_storage_tally_interval_start, bucket_storage_tally_inline, bucket_storage_tally_remote, bucket_storage_tally_remote_segments_count, bucket_storage_tally_inline_segments_count, bucket_storage_tally_object_count, bucket_storage_tally_metadata_size)

}

func (rx *Rx) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_BucketUsage(ctx, bucket_usage_id, bucket_usage_bucket_id, bucket_usage_rollup_end_time, bucket_usage_remote_stored_data, bucket_usage_inline_stored_data, bucket_usage_remote_segments, bucket_usage_inline_segments, bucket_usage_objects, bucket_usage_metadata_size, bucket_usage_repair_egress, bucket_usage_get_egress, bucket_usage_audit_egress)

}

func (rx *Rx) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_CertRecord(ctx, certRecord_publickey, certRecord_id)

}

func (rx *Rx) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Irreparabledb(ctx, irreparabledb_segmentpath, irreparabledb_segmentdetail, irreparabledb_pieces_lost_count, irreparabledb_seg_damaged_unix_sec, irreparabledb_repair_attempt_count)

}

func (rx *Rx) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_last_net Node_LastNet_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_major Node_Major_Field,
	node_minor Node_Minor_Field,
	node_patch Node_Patch_Field,
	node_hash Node_Hash_Field,
	node_timestamp Node_Timestamp_Field,
	node_release Node_Release_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field,
	node_contained Node_Contained_Field,
	node_audit_reputation_alpha Node_AuditReputationAlpha_Field,
	node_audit_reputation_beta Node_AuditReputationBeta_Field,
	node_uptime_reputation_alpha Node_UptimeReputationAlpha_Field,
	node_uptime_reputation_beta Node_UptimeReputationBeta_Field,
	optional Node_Create_Fields) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Node(ctx, node_id, node_address, node_last_net, node_protocol, node_type, node_email, node_wallet, node_free_bandwidth, node_free_disk, node_major, node_minor, node_patch, node_hash, node_timestamp, node_release, node_latency_90, node_audit_success_count, node_total_audit_count, node_uptime_success_count, node_total_uptime_count, node_last_contact_success, node_last_contact_failure, node_contained, node_audit_reputation_alpha, node_audit_reputation_beta, node_uptime_reputation_alpha, node_uptime_reputation_beta, optional)

}

func (rx *Rx) Create_Offer(ctx context.Context,
	offer_name Offer_Name_Field,
	offer_description Offer_Description_Field,
	offer_award_credit_in_cents Offer_AwardCreditInCents_Field,
	offer_invitee_credit_in_cents Offer_InviteeCreditInCents_Field,
	offer_expires_at Offer_ExpiresAt_Field,
	offer_status Offer_Status_Field,
	offer_type Offer_Type_Field,
	optional Offer_Create_Fields) (
	offer *Offer, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Offer(ctx, offer_name, offer_description, offer_award_credit_in_cents, offer_invitee_credit_in_cents, offer_expires_at, offer_status, offer_type, optional)

}

func (rx *Rx) Create_PendingAudits(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	pending_audits_piece_id PendingAudits_PieceId_Field,
	pending_audits_stripe_index PendingAudits_StripeIndex_Field,
	pending_audits_share_size PendingAudits_ShareSize_Field,
	pending_audits_expected_share_hash PendingAudits_ExpectedShareHash_Field,
	pending_audits_reverify_count PendingAudits_ReverifyCount_Field,
	pending_audits_path PendingAudits_Path_Field) (
	pending_audits *PendingAudits, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_PendingAudits(ctx, pending_audits_node_id, pending_audits_piece_id, pending_audits_stripe_index, pending_audits_share_size, pending_audits_expected_share_hash, pending_audits_reverify_count, pending_audits_path)

}

func (rx *Rx) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field,
	project_usage_limit Project_UsageLimit_Field,
	optional Project_Create_Fields) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Project(ctx, project_id, project_name, project_description, project_usage_limit, optional)

}

func (rx *Rx) Create_ProjectInvoiceStamp(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_invoice_id ProjectInvoiceStamp_InvoiceId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field,
	project_invoice_stamp_end_date ProjectInvoiceStamp_EndDate_Field,
	project_invoice_stamp_created_at ProjectInvoiceStamp_CreatedAt_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ProjectInvoiceStamp(ctx, project_invoice_stamp_project_id, project_invoice_stamp_invoice_id, project_invoice_stamp_start_date, project_invoice_stamp_end_date, project_invoice_stamp_created_at)

}

func (rx *Rx) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ProjectMember(ctx, project_member_member_id, project_member_project_id)

}

func (rx *Rx) Create_ProjectPayment(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	project_payment_project_id ProjectPayment_ProjectId_Field,
	project_payment_payer_id ProjectPayment_PayerId_Field,
	project_payment_payment_method_id ProjectPayment_PaymentMethodId_Field,
	project_payment_is_default ProjectPayment_IsDefault_Field) (
	project_payment *ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ProjectPayment(ctx, project_payment_id, project_payment_project_id, project_payment_payer_id, project_payment_payment_method_id, project_payment_is_default)

}

func (rx *Rx) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_RegistrationToken(ctx, registration_token_secret, registration_token_project_limit, optional)

}

func (rx *Rx) Create_ResetPasswordToken(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ResetPasswordToken(ctx, reset_password_token_secret, reset_password_token_owner_id)

}

func (rx *Rx) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_SerialNumber(ctx, serial_number_serial_number, serial_number_bucket_id, serial_number_expires_at)

}

func (rx *Rx) Create_StoragenodeStorageTally(ctx context.Context,
	storagenode_storage_tally_node_id StoragenodeStorageTally_NodeId_Field,
	storagenode_storage_tally_interval_end_time StoragenodeStorageTally_IntervalEndTime_Field,
	storagenode_storage_tally_data_total StoragenodeStorageTally_DataTotal_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_StoragenodeStorageTally(ctx, storagenode_storage_tally_node_id, storagenode_storage_tally_interval_end_time, storagenode_storage_tally_data_total)

}

func (rx *Rx) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_UsedSerial(ctx, used_serial_serial_number_id, used_serial_storage_node_id)

}

func (rx *Rx) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_full_name User_FullName_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_User(ctx, user_id, user_email, user_full_name, user_password_hash, optional)

}

func (rx *Rx) Create_UserCredit(ctx context.Context,
	user_credit_user_id UserCredit_UserId_Field,
	user_credit_offer_id UserCredit_OfferId_Field,
	user_credit_credits_earned_in_cents UserCredit_CreditsEarnedInCents_Field,
	user_credit_expires_at UserCredit_ExpiresAt_Field,
	optional UserCredit_Create_Fields) (
	user_credit *UserCredit, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_UserCredit(ctx, user_credit_user_id, user_credit_offer_id, user_credit_credits_earned_in_cents, user_credit_expires_at, optional)

}

func (rx *Rx) Create_UserPayment(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field,
	user_payment_customer_id UserPayment_CustomerId_Field) (
	user_payment *UserPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_UserPayment(ctx, user_payment_user_id, user_payment_customer_id)

}

func (rx *Rx) Create_ValueAttribution(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field,
	value_attribution_partner_id ValueAttribution_PartnerId_Field) (
	value_attribution *ValueAttribution, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ValueAttribution(ctx, value_attribution_project_id, value_attribution_bucket_name, value_attribution_partner_id)

}

func (rx *Rx) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_AccountingRollup_By_Id(ctx, accounting_rollup_id)
}

func (rx *Rx) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ApiKey_By_Id(ctx, api_key_id)
}

func (rx *Rx) Delete_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_BucketMetainfo_By_ProjectId_And_Name(ctx, bucket_metainfo_project_id, bucket_metainfo_name)
}

func (rx *Rx) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_BucketUsage_By_Id(ctx, bucket_usage_id)
}

func (rx *Rx) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_CertRecord_By_Id(ctx, certRecord_id)
}

func (rx *Rx) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath)
}

func (rx *Rx) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Node_By_Id(ctx, node_id)
}

func (rx *Rx) Delete_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_PendingAudits_By_NodeId(ctx, pending_audits_node_id)
}

func (rx *Rx) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ProjectMember_By_MemberId_And_ProjectId(ctx, project_member_member_id, project_member_project_id)
}

func (rx *Rx) Delete_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ProjectPayment_By_Id(ctx, project_payment_id)
}

func (rx *Rx) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Project_By_Id(ctx, project_id)
}

func (rx *Rx) Delete_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ResetPasswordToken_By_Secret(ctx, reset_password_token_secret)
}

func (rx *Rx) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx, serial_number_expires_at_less_or_equal)

}

func (rx *Rx) Delete_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_StoragenodeStorageTally_By_Id(ctx, storagenode_storage_tally_id)
}

func (rx *Rx) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_User_By_Id(ctx, user_id)
}

func (rx *Rx) Delete_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ValueAttribution_By_ProjectId_And_BucketName(ctx, value_attribution_project_id, value_attribution_bucket_name)
}

func (rx *Rx) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_AccountingTimestamps_Value_By_Name(ctx, accounting_timestamps_name)
}

func (rx *Rx) Find_BucketBandwidthRollup_By_BucketName_And_ProjectId_And_IntervalStart_And_Action(ctx context.Context,
	bucket_bandwidth_rollup_bucket_name BucketBandwidthRollup_BucketName_Field,
	bucket_bandwidth_rollup_project_id BucketBandwidthRollup_ProjectId_Field,
	bucket_bandwidth_rollup_interval_start BucketBandwidthRollup_IntervalStart_Field,
	bucket_bandwidth_rollup_action BucketBandwidthRollup_Action_Field) (
	bucket_bandwidth_rollup *BucketBandwidthRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_BucketBandwidthRollup_By_BucketName_And_ProjectId_And_IntervalStart_And_Action(ctx, bucket_bandwidth_rollup_bucket_name, bucket_bandwidth_rollup_project_id, bucket_bandwidth_rollup_interval_start, bucket_bandwidth_rollup_action)
}

func (rx *Rx) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_SerialNumber_By_SerialNumber(ctx, serial_number_serial_number)
}

func (rx *Rx) Find_StoragenodeBandwidthRollup_By_StoragenodeId_And_IntervalStart_And_Action(ctx context.Context,
	storagenode_bandwidth_rollup_storagenode_id StoragenodeBandwidthRollup_StoragenodeId_Field,
	storagenode_bandwidth_rollup_interval_start StoragenodeBandwidthRollup_IntervalStart_Field,
	storagenode_bandwidth_rollup_action StoragenodeBandwidthRollup_Action_Field) (
	storagenode_bandwidth_rollup *StoragenodeBandwidthRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_StoragenodeBandwidthRollup_By_StoragenodeId_And_IntervalStart_And_Action(ctx, storagenode_bandwidth_rollup_storagenode_id, storagenode_bandwidth_rollup_interval_start, storagenode_bandwidth_rollup_action)
}

func (rx *Rx) First_BucketStorageTally_By_ProjectId_OrderBy_Desc_IntervalStart(ctx context.Context,
	bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.First_BucketStorageTally_By_ProjectId_OrderBy_Desc_IntervalStart(ctx, bucket_storage_tally_project_id)
}

func (rx *Rx) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_AccountingRollup_By_Id(ctx, accounting_rollup_id)
}

func (rx *Rx) Get_ApiKey_By_Head(ctx context.Context,
	api_key_head ApiKey_Head_Field) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ApiKey_By_Head(ctx, api_key_head)
}

func (rx *Rx) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ApiKey_By_Id(ctx, api_key_id)
}

func (rx *Rx) Get_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field) (
	bucket_metainfo *BucketMetainfo, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_BucketMetainfo_By_ProjectId_And_Name(ctx, bucket_metainfo_project_id, bucket_metainfo_name)
}

func (rx *Rx) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_BucketUsage_By_Id(ctx, bucket_usage_id)
}

func (rx *Rx) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_CertRecord_By_Id(ctx, certRecord_id)
}

func (rx *Rx) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath)
}

func (rx *Rx) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Node_By_Id(ctx, node_id)
}

func (rx *Rx) Get_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field) (
	offer *Offer, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Offer_By_Id(ctx, offer_id)
}

func (rx *Rx) Get_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field) (
	pending_audits *PendingAudits, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_PendingAudits_By_NodeId(ctx, pending_audits_node_id)
}

func (rx *Rx) Get_ProjectInvoiceStamp_By_ProjectId_And_StartDate(ctx context.Context,
	project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
	project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field) (
	project_invoice_stamp *ProjectInvoiceStamp, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ProjectInvoiceStamp_By_ProjectId_And_StartDate(ctx, project_invoice_stamp_project_id, project_invoice_stamp_start_date)
}

func (rx *Rx) Get_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field) (
	project_payment *ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ProjectPayment_By_Id(ctx, project_payment_id)
}

func (rx *Rx) Get_ProjectPayment_By_ProjectId_And_IsDefault_Equal_True(ctx context.Context,
	project_payment_project_id ProjectPayment_ProjectId_Field) (
	project_payment *ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ProjectPayment_By_ProjectId_And_IsDefault_Equal_True(ctx, project_payment_project_id)
}

func (rx *Rx) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Project_By_Id(ctx, project_id)
}

func (rx *Rx) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_RegistrationToken_By_OwnerId(ctx, registration_token_owner_id)
}

func (rx *Rx) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_RegistrationToken_By_Secret(ctx, registration_token_secret)
}

func (rx *Rx) Get_ResetPasswordToken_By_OwnerId(ctx context.Context,
	reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
	reset_password_token *ResetPasswordToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ResetPasswordToken_By_OwnerId(ctx, reset_password_token_owner_id)
}

func (rx *Rx) Get_ResetPasswordToken_By_Secret(ctx context.Context,
	reset_password_token_secret ResetPasswordToken_Secret_Field) (
	reset_password_token *ResetPasswordToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ResetPasswordToken_By_Secret(ctx, reset_password_token_secret)
}

func (rx *Rx) Get_StoragenodeStorageTally_By_Id(ctx context.Context,
	storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
	storagenode_storage_tally *StoragenodeStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_StoragenodeStorageTally_By_Id(ctx, storagenode_storage_tally_id)
}

func (rx *Rx) Get_UserPayment_By_UserId(ctx context.Context,
	user_payment_user_id UserPayment_UserId_Field) (
	user_payment *UserPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_UserPayment_By_UserId(ctx, user_payment_user_id)
}

func (rx *Rx) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_User_By_Email_And_Status_Not_Number(ctx, user_email)
}

func (rx *Rx) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_User_By_Id(ctx, user_id)
}

func (rx *Rx) Get_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
	value_attribution_project_id ValueAttribution_ProjectId_Field,
	value_attribution_bucket_name ValueAttribution_BucketName_Field) (
	value_attribution *ValueAttribution, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ValueAttribution_By_ProjectId_And_BucketName(ctx, value_attribution_project_id, value_attribution_bucket_name)
}

func (rx *Rx) Limited_BucketMetainfo_By_ProjectId_And_Name_GreaterOrEqual_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater_or_equal BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketMetainfo_By_ProjectId_And_Name_GreaterOrEqual_OrderBy_Asc_Name(ctx, bucket_metainfo_project_id, bucket_metainfo_name_greater_or_equal, limit, offset)
}

func (rx *Rx) Limited_BucketMetainfo_By_ProjectId_And_Name_Greater_OrderBy_Asc_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name_greater BucketMetainfo_Name_Field,
	limit int, offset int64) (
	rows []*BucketMetainfo, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketMetainfo_By_ProjectId_And_Name_Greater_OrderBy_Asc_Name(ctx, bucket_metainfo_project_id, bucket_metainfo_name_greater, limit, offset)
}

func (rx *Rx) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx, bucket_usage_bucket_id, bucket_usage_rollup_end_time_greater, bucket_usage_rollup_end_time_less_or_equal, limit, offset)
}

func (rx *Rx) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx, bucket_usage_bucket_id, bucket_usage_rollup_end_time_greater, bucket_usage_rollup_end_time_less_or_equal, limit, offset)
}

func (rx *Rx) Limited_Irreparabledb_By_Segmentpath_Greater_OrderBy_Asc_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath_greater Irreparabledb_Segmentpath_Field,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Irreparabledb_By_Segmentpath_Greater_OrderBy_Asc_Segmentpath(ctx, irreparabledb_segmentpath_greater, limit, offset)
}

func (rx *Rx) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx, node_id_greater_or_equal, limit, offset)
}

func (rx *Rx) Limited_Node_Id_Node_LastNet_Node_Address_Node_Protocol_By_Id_GreaterOrEqual_And_Disqualified_Is_Null_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Id_LastNet_Address_Protocol_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Node_Id_Node_LastNet_Node_Address_Node_Protocol_By_Id_GreaterOrEqual_And_Disqualified_Is_Null_OrderBy_Asc_Id(ctx, node_id_greater_or_equal, limit, offset)
}

func (rx *Rx) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_ProjectMember_By_ProjectId(ctx, project_member_project_id, limit, offset)
}

func (rx *Rx) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_AccountingTimestamps_By_Name(ctx, accounting_timestamps_name, update)
}

func (rx *Rx) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_ApiKey_By_Id(ctx, api_key_id, update)
}

func (rx *Rx) Update_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
	bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
	bucket_metainfo_name BucketMetainfo_Name_Field,
	update BucketMetainfo_Update_Fields) (
	bucket_metainfo *BucketMetainfo, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_BucketMetainfo_By_ProjectId_And_Name(ctx, bucket_metainfo_project_id, bucket_metainfo_name, update)
}

func (rx *Rx) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_CertRecord_By_Id(ctx, certRecord_id, update)
}

func (rx *Rx) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath, update)
}

func (rx *Rx) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Node_By_Id(ctx, node_id, update)
}

func (rx *Rx) Update_Offer_By_Id(ctx context.Context,
	offer_id Offer_Id_Field,
	update Offer_Update_Fields) (
	offer *Offer, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Offer_By_Id(ctx, offer_id, update)
}

func (rx *Rx) Update_PendingAudits_By_NodeId(ctx context.Context,
	pending_audits_node_id PendingAudits_NodeId_Field,
	update PendingAudits_Update_Fields) (
	pending_audits *PendingAudits, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_PendingAudits_By_NodeId(ctx, pending_audits_node_id, update)
}

func (rx *Rx) Update_ProjectPayment_By_Id(ctx context.Context,
	project_payment_id ProjectPayment_Id_Field,
	update ProjectPayment_Update_Fields) (
	project_payment *ProjectPayment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_ProjectPayment_By_Id(ctx, project_payment_id, update)
}

func (rx *Rx) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Project_By_Id(ctx, project_id, update)
}

func (rx *Rx) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_RegistrationToken_By_Secret(ctx, registration_token_secret, update)
}

func (rx *Rx) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_User_By_Id(ctx, user_id, update)
}

type Methods interface {
	All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
		accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
		rows []*AccountingRollup, err error)

	All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
		api_key_project_id ApiKey_ProjectId_Field) (
		rows []*ApiKey, err error)

	All_BucketStorageTally_By_ProjectId_And_BucketName_And_IntervalStart_GreaterOrEqual_And_IntervalStart_LessOrEqual_OrderBy_Desc_IntervalStart(ctx context.Context,
		bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
		bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
		bucket_storage_tally_interval_start_greater_or_equal BucketStorageTally_IntervalStart_Field,
		bucket_storage_tally_interval_start_less_or_equal BucketStorageTally_IntervalStart_Field) (
		rows []*BucketStorageTally, err error)

	All_Node_Id(ctx context.Context) (
		rows []*Id_Row, err error)

	All_Offer_OrderBy_Asc_Id(ctx context.Context) (
		rows []*Offer, err error)

	All_Project(ctx context.Context) (
		rows []*Project, err error)

	All_ProjectInvoiceStamp_By_ProjectId_OrderBy_Desc_StartDate(ctx context.Context,
		project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field) (
		rows []*ProjectInvoiceStamp, err error)

	All_ProjectMember_By_MemberId(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field) (
		rows []*ProjectMember, err error)

	All_ProjectPayment_By_PayerId(ctx context.Context,
		project_payment_payer_id ProjectPayment_PayerId_Field) (
		rows []*ProjectPayment, err error)

	All_ProjectPayment_By_ProjectId(ctx context.Context,
		project_payment_project_id ProjectPayment_ProjectId_Field) (
		rows []*ProjectPayment, err error)

	All_Project_By_CreatedAt_Less_OrderBy_Asc_CreatedAt(ctx context.Context,
		project_created_at_less Project_CreatedAt_Field) (
		rows []*Project, err error)

	All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field) (
		rows []*Project, err error)

	All_StoragenodeBandwidthRollup_By_IntervalStart_GreaterOrEqual(ctx context.Context,
		storagenode_bandwidth_rollup_interval_start_greater_or_equal StoragenodeBandwidthRollup_IntervalStart_Field) (
		rows []*StoragenodeBandwidthRollup, err error)

	All_StoragenodeStorageTally(ctx context.Context) (
		rows []*StoragenodeStorageTally, err error)

	All_StoragenodeStorageTally_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
		storagenode_storage_tally_interval_end_time_greater_or_equal StoragenodeStorageTally_IntervalEndTime_Field) (
		rows []*StoragenodeStorageTally, err error)

	All_UserCredit_By_UserId_And_ExpiresAt_Greater_And_CreditsUsedInCents_Less_CreditsEarnedInCents_OrderBy_Asc_ExpiresAt(ctx context.Context,
		user_credit_user_id UserCredit_UserId_Field,
		user_credit_expires_at_greater UserCredit_ExpiresAt_Field) (
		rows []*UserCredit, err error)

	Count_UserCredit_By_ReferredBy(ctx context.Context,
		user_credit_referred_by UserCredit_ReferredBy_Field) (
		count int64, err error)

	Create_AccountingRollup(ctx context.Context,
		accounting_rollup_node_id AccountingRollup_NodeId_Field,
		accounting_rollup_start_time AccountingRollup_StartTime_Field,
		accounting_rollup_put_total AccountingRollup_PutTotal_Field,
		accounting_rollup_get_total AccountingRollup_GetTotal_Field,
		accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
		accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
		accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
		accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
		accounting_rollup *AccountingRollup, err error)

	Create_AccountingTimestamps(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field,
		accounting_timestamps_value AccountingTimestamps_Value_Field) (
		accounting_timestamps *AccountingTimestamps, err error)

	Create_ApiKey(ctx context.Context,
		api_key_id ApiKey_Id_Field,
		api_key_project_id ApiKey_ProjectId_Field,
		api_key_head ApiKey_Head_Field,
		api_key_name ApiKey_Name_Field,
		api_key_secret ApiKey_Secret_Field,
		optional ApiKey_Create_Fields) (
		api_key *ApiKey, err error)

	Create_BucketMetainfo(ctx context.Context,
		bucket_metainfo_id BucketMetainfo_Id_Field,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name BucketMetainfo_Name_Field,
		bucket_metainfo_path_cipher BucketMetainfo_PathCipher_Field,
		bucket_metainfo_default_segment_size BucketMetainfo_DefaultSegmentSize_Field,
		bucket_metainfo_default_encryption_cipher_suite BucketMetainfo_DefaultEncryptionCipherSuite_Field,
		bucket_metainfo_default_encryption_block_size BucketMetainfo_DefaultEncryptionBlockSize_Field,
		bucket_metainfo_default_redundancy_algorithm BucketMetainfo_DefaultRedundancyAlgorithm_Field,
		bucket_metainfo_default_redundancy_share_size BucketMetainfo_DefaultRedundancyShareSize_Field,
		bucket_metainfo_default_redundancy_required_shares BucketMetainfo_DefaultRedundancyRequiredShares_Field,
		bucket_metainfo_default_redundancy_repair_shares BucketMetainfo_DefaultRedundancyRepairShares_Field,
		bucket_metainfo_default_redundancy_optimal_shares BucketMetainfo_DefaultRedundancyOptimalShares_Field,
		bucket_metainfo_default_redundancy_total_shares BucketMetainfo_DefaultRedundancyTotalShares_Field,
		optional BucketMetainfo_Create_Fields) (
		bucket_metainfo *BucketMetainfo, err error)

	Create_BucketStorageTally(ctx context.Context,
		bucket_storage_tally_bucket_name BucketStorageTally_BucketName_Field,
		bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field,
		bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
		bucket_storage_tally_inline BucketStorageTally_Inline_Field,
		bucket_storage_tally_remote BucketStorageTally_Remote_Field,
		bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
		bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
		bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
		bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
		bucket_storage_tally *BucketStorageTally, err error)

	Create_BucketUsage(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
		bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
		bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
		bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
		bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
		bucket_usage_objects BucketUsage_Objects_Field,
		bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
		bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
		bucket_usage_get_egress BucketUsage_GetEgress_Field,
		bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
		bucket_usage *BucketUsage, err error)

	Create_CertRecord(ctx context.Context,
		certRecord_publickey CertRecord_Publickey_Field,
		certRecord_id CertRecord_Id_Field) (
		certRecord *CertRecord, err error)

	Create_Irreparabledb(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
		irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
		irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
		irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
		irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
		irreparabledb *Irreparabledb, err error)

	Create_Node(ctx context.Context,
		node_id Node_Id_Field,
		node_address Node_Address_Field,
		node_last_net Node_LastNet_Field,
		node_protocol Node_Protocol_Field,
		node_type Node_Type_Field,
		node_email Node_Email_Field,
		node_wallet Node_Wallet_Field,
		node_free_bandwidth Node_FreeBandwidth_Field,
		node_free_disk Node_FreeDisk_Field,
		node_major Node_Major_Field,
		node_minor Node_Minor_Field,
		node_patch Node_Patch_Field,
		node_hash Node_Hash_Field,
		node_timestamp Node_Timestamp_Field,
		node_release Node_Release_Field,
		node_latency_90 Node_Latency90_Field,
		node_audit_success_count Node_AuditSuccessCount_Field,
		node_total_audit_count Node_TotalAuditCount_Field,
		node_uptime_success_count Node_UptimeSuccessCount_Field,
		node_total_uptime_count Node_TotalUptimeCount_Field,
		node_last_contact_success Node_LastContactSuccess_Field,
		node_last_contact_failure Node_LastContactFailure_Field,
		node_contained Node_Contained_Field,
		node_audit_reputation_alpha Node_AuditReputationAlpha_Field,
		node_audit_reputation_beta Node_AuditReputationBeta_Field,
		node_uptime_reputation_alpha Node_UptimeReputationAlpha_Field,
		node_uptime_reputation_beta Node_UptimeReputationBeta_Field,
		optional Node_Create_Fields) (
		node *Node, err error)

	Create_Offer(ctx context.Context,
		offer_name Offer_Name_Field,
		offer_description Offer_Description_Field,
		offer_award_credit_in_cents Offer_AwardCreditInCents_Field,
		offer_invitee_credit_in_cents Offer_InviteeCreditInCents_Field,
		offer_expires_at Offer_ExpiresAt_Field,
		offer_status Offer_Status_Field,
		offer_type Offer_Type_Field,
		optional Offer_Create_Fields) (
		offer *Offer, err error)

	Create_PendingAudits(ctx context.Context,
		pending_audits_node_id PendingAudits_NodeId_Field,
		pending_audits_piece_id PendingAudits_PieceId_Field,
		pending_audits_stripe_index PendingAudits_StripeIndex_Field,
		pending_audits_share_size PendingAudits_ShareSize_Field,
		pending_audits_expected_share_hash PendingAudits_ExpectedShareHash_Field,
		pending_audits_reverify_count PendingAudits_ReverifyCount_Field,
		pending_audits_path PendingAudits_Path_Field) (
		pending_audits *PendingAudits, err error)

	Create_Project(ctx context.Context,
		project_id Project_Id_Field,
		project_name Project_Name_Field,
		project_description Project_Description_Field,
		project_usage_limit Project_UsageLimit_Field,
		optional Project_Create_Fields) (
		project *Project, err error)

	Create_ProjectInvoiceStamp(ctx context.Context,
		project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
		project_invoice_stamp_invoice_id ProjectInvoiceStamp_InvoiceId_Field,
		project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field,
		project_invoice_stamp_end_date ProjectInvoiceStamp_EndDate_Field,
		project_invoice_stamp_created_at ProjectInvoiceStamp_CreatedAt_Field) (
		project_invoice_stamp *ProjectInvoiceStamp, err error)

	Create_ProjectMember(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field,
		project_member_project_id ProjectMember_ProjectId_Field) (
		project_member *ProjectMember, err error)

	Create_ProjectPayment(ctx context.Context,
		project_payment_id ProjectPayment_Id_Field,
		project_payment_project_id ProjectPayment_ProjectId_Field,
		project_payment_payer_id ProjectPayment_PayerId_Field,
		project_payment_payment_method_id ProjectPayment_PaymentMethodId_Field,
		project_payment_is_default ProjectPayment_IsDefault_Field) (
		project_payment *ProjectPayment, err error)

	Create_RegistrationToken(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field,
		registration_token_project_limit RegistrationToken_ProjectLimit_Field,
		optional RegistrationToken_Create_Fields) (
		registration_token *RegistrationToken, err error)

	Create_ResetPasswordToken(ctx context.Context,
		reset_password_token_secret ResetPasswordToken_Secret_Field,
		reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
		reset_password_token *ResetPasswordToken, err error)

	Create_SerialNumber(ctx context.Context,
		serial_number_serial_number SerialNumber_SerialNumber_Field,
		serial_number_bucket_id SerialNumber_BucketId_Field,
		serial_number_expires_at SerialNumber_ExpiresAt_Field) (
		serial_number *SerialNumber, err error)

	Create_StoragenodeStorageTally(ctx context.Context,
		storagenode_storage_tally_node_id StoragenodeStorageTally_NodeId_Field,
		storagenode_storage_tally_interval_end_time StoragenodeStorageTally_IntervalEndTime_Field,
		storagenode_storage_tally_data_total StoragenodeStorageTally_DataTotal_Field) (
		storagenode_storage_tally *StoragenodeStorageTally, err error)

	Create_UsedSerial(ctx context.Context,
		used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
		used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
		used_serial *UsedSerial, err error)

	Create_User(ctx context.Context,
		user_id User_Id_Field,
		user_email User_Email_Field,
		user_full_name User_FullName_Field,
		user_password_hash User_PasswordHash_Field,
		optional User_Create_Fields) (
		user *User, err error)

	Create_UserCredit(ctx context.Context,
		user_credit_user_id UserCredit_UserId_Field,
		user_credit_offer_id UserCredit_OfferId_Field,
		user_credit_credits_earned_in_cents UserCredit_CreditsEarnedInCents_Field,
		user_credit_expires_at UserCredit_ExpiresAt_Field,
		optional UserCredit_Create_Fields) (
		user_credit *UserCredit, err error)

	Create_UserPayment(ctx context.Context,
		user_payment_user_id UserPayment_UserId_Field,
		user_payment_customer_id UserPayment_CustomerId_Field) (
		user_payment *UserPayment, err error)

	Create_ValueAttribution(ctx context.Context,
		value_attribution_project_id ValueAttribution_ProjectId_Field,
		value_attribution_bucket_name ValueAttribution_BucketName_Field,
		value_attribution_partner_id ValueAttribution_PartnerId_Field) (
		value_attribution *ValueAttribution, err error)

	Delete_AccountingRollup_By_Id(ctx context.Context,
		accounting_rollup_id AccountingRollup_Id_Field) (
		deleted bool, err error)

	Delete_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field) (
		deleted bool, err error)

	Delete_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name BucketMetainfo_Name_Field) (
		deleted bool, err error)

	Delete_BucketUsage_By_Id(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field) (
		deleted bool, err error)

	Delete_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field) (
		deleted bool, err error)

	Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
		deleted bool, err error)

	Delete_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field) (
		deleted bool, err error)

	Delete_PendingAudits_By_NodeId(ctx context.Context,
		pending_audits_node_id PendingAudits_NodeId_Field) (
		deleted bool, err error)

	Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field,
		project_member_project_id ProjectMember_ProjectId_Field) (
		deleted bool, err error)

	Delete_ProjectPayment_By_Id(ctx context.Context,
		project_payment_id ProjectPayment_Id_Field) (
		deleted bool, err error)

	Delete_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field) (
		deleted bool, err error)

	Delete_ResetPasswordToken_By_Secret(ctx context.Context,
		reset_password_token_secret ResetPasswordToken_Secret_Field) (
		deleted bool, err error)

	Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
		serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
		count int64, err error)

	Delete_StoragenodeStorageTally_By_Id(ctx context.Context,
		storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
		deleted bool, err error)

	Delete_User_By_Id(ctx context.Context,
		user_id User_Id_Field) (
		deleted bool, err error)

	Delete_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
		value_attribution_project_id ValueAttribution_ProjectId_Field,
		value_attribution_bucket_name ValueAttribution_BucketName_Field) (
		deleted bool, err error)

	Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field) (
		row *Value_Row, err error)

	Find_BucketBandwidthRollup_By_BucketName_And_ProjectId_And_IntervalStart_And_Action(ctx context.Context,
		bucket_bandwidth_rollup_bucket_name BucketBandwidthRollup_BucketName_Field,
		bucket_bandwidth_rollup_project_id BucketBandwidthRollup_ProjectId_Field,
		bucket_bandwidth_rollup_interval_start BucketBandwidthRollup_IntervalStart_Field,
		bucket_bandwidth_rollup_action BucketBandwidthRollup_Action_Field) (
		bucket_bandwidth_rollup *BucketBandwidthRollup, err error)

	Find_SerialNumber_By_SerialNumber(ctx context.Context,
		serial_number_serial_number SerialNumber_SerialNumber_Field) (
		serial_number *SerialNumber, err error)

	Find_StoragenodeBandwidthRollup_By_StoragenodeId_And_IntervalStart_And_Action(ctx context.Context,
		storagenode_bandwidth_rollup_storagenode_id StoragenodeBandwidthRollup_StoragenodeId_Field,
		storagenode_bandwidth_rollup_interval_start StoragenodeBandwidthRollup_IntervalStart_Field,
		storagenode_bandwidth_rollup_action StoragenodeBandwidthRollup_Action_Field) (
		storagenode_bandwidth_rollup *StoragenodeBandwidthRollup, err error)

	First_BucketStorageTally_By_ProjectId_OrderBy_Desc_IntervalStart(ctx context.Context,
		bucket_storage_tally_project_id BucketStorageTally_ProjectId_Field) (
		bucket_storage_tally *BucketStorageTally, err error)

	Get_AccountingRollup_By_Id(ctx context.Context,
		accounting_rollup_id AccountingRollup_Id_Field) (
		accounting_rollup *AccountingRollup, err error)

	Get_ApiKey_By_Head(ctx context.Context,
		api_key_head ApiKey_Head_Field) (
		api_key *ApiKey, err error)

	Get_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field) (
		api_key *ApiKey, err error)

	Get_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name BucketMetainfo_Name_Field) (
		bucket_metainfo *BucketMetainfo, err error)

	Get_BucketUsage_By_Id(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field) (
		bucket_usage *BucketUsage, err error)

	Get_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field) (
		certRecord *CertRecord, err error)

	Get_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
		irreparabledb *Irreparabledb, err error)

	Get_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field) (
		node *Node, err error)

	Get_Offer_By_Id(ctx context.Context,
		offer_id Offer_Id_Field) (
		offer *Offer, err error)

	Get_PendingAudits_By_NodeId(ctx context.Context,
		pending_audits_node_id PendingAudits_NodeId_Field) (
		pending_audits *PendingAudits, err error)

	Get_ProjectInvoiceStamp_By_ProjectId_And_StartDate(ctx context.Context,
		project_invoice_stamp_project_id ProjectInvoiceStamp_ProjectId_Field,
		project_invoice_stamp_start_date ProjectInvoiceStamp_StartDate_Field) (
		project_invoice_stamp *ProjectInvoiceStamp, err error)

	Get_ProjectPayment_By_Id(ctx context.Context,
		project_payment_id ProjectPayment_Id_Field) (
		project_payment *ProjectPayment, err error)

	Get_ProjectPayment_By_ProjectId_And_IsDefault_Equal_True(ctx context.Context,
		project_payment_project_id ProjectPayment_ProjectId_Field) (
		project_payment *ProjectPayment, err error)

	Get_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field) (
		project *Project, err error)

	Get_RegistrationToken_By_OwnerId(ctx context.Context,
		registration_token_owner_id RegistrationToken_OwnerId_Field) (
		registration_token *RegistrationToken, err error)

	Get_RegistrationToken_By_Secret(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field) (
		registration_token *RegistrationToken, err error)

	Get_ResetPasswordToken_By_OwnerId(ctx context.Context,
		reset_password_token_owner_id ResetPasswordToken_OwnerId_Field) (
		reset_password_token *ResetPasswordToken, err error)

	Get_ResetPasswordToken_By_Secret(ctx context.Context,
		reset_password_token_secret ResetPasswordToken_Secret_Field) (
		reset_password_token *ResetPasswordToken, err error)

	Get_StoragenodeStorageTally_By_Id(ctx context.Context,
		storagenode_storage_tally_id StoragenodeStorageTally_Id_Field) (
		storagenode_storage_tally *StoragenodeStorageTally, err error)

	Get_UserPayment_By_UserId(ctx context.Context,
		user_payment_user_id UserPayment_UserId_Field) (
		user_payment *UserPayment, err error)

	Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
		user_email User_Email_Field) (
		user *User, err error)

	Get_User_By_Id(ctx context.Context,
		user_id User_Id_Field) (
		user *User, err error)

	Get_ValueAttribution_By_ProjectId_And_BucketName(ctx context.Context,
		value_attribution_project_id ValueAttribution_ProjectId_Field,
		value_attribution_bucket_name ValueAttribution_BucketName_Field) (
		value_attribution *ValueAttribution, err error)

	Limited_BucketMetainfo_By_ProjectId_And_Name_GreaterOrEqual_OrderBy_Asc_Name(ctx context.Context,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name_greater_or_equal BucketMetainfo_Name_Field,
		limit int, offset int64) (
		rows []*BucketMetainfo, err error)

	Limited_BucketMetainfo_By_ProjectId_And_Name_Greater_OrderBy_Asc_Name(ctx context.Context,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name_greater BucketMetainfo_Name_Field,
		limit int, offset int64) (
		rows []*BucketMetainfo, err error)

	Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
		bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
		limit int, offset int64) (
		rows []*BucketUsage, err error)

	Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
		bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
		limit int, offset int64) (
		rows []*BucketUsage, err error)

	Limited_Irreparabledb_By_Segmentpath_Greater_OrderBy_Asc_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath_greater Irreparabledb_Segmentpath_Field,
		limit int, offset int64) (
		rows []*Irreparabledb, err error)

	Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
		node_id_greater_or_equal Node_Id_Field,
		limit int, offset int64) (
		rows []*Node, err error)

	Limited_Node_Id_Node_LastNet_Node_Address_Node_Protocol_By_Id_GreaterOrEqual_And_Disqualified_Is_Null_OrderBy_Asc_Id(ctx context.Context,
		node_id_greater_or_equal Node_Id_Field,
		limit int, offset int64) (
		rows []*Id_LastNet_Address_Protocol_Row, err error)

	Limited_ProjectMember_By_ProjectId(ctx context.Context,
		project_member_project_id ProjectMember_ProjectId_Field,
		limit int, offset int64) (
		rows []*ProjectMember, err error)

	Update_AccountingTimestamps_By_Name(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field,
		update AccountingTimestamps_Update_Fields) (
		accounting_timestamps *AccountingTimestamps, err error)

	Update_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field,
		update ApiKey_Update_Fields) (
		api_key *ApiKey, err error)

	Update_BucketMetainfo_By_ProjectId_And_Name(ctx context.Context,
		bucket_metainfo_project_id BucketMetainfo_ProjectId_Field,
		bucket_metainfo_name BucketMetainfo_Name_Field,
		update BucketMetainfo_Update_Fields) (
		bucket_metainfo *BucketMetainfo, err error)

	Update_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field,
		update CertRecord_Update_Fields) (
		certRecord *CertRecord, err error)

	Update_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
		update Irreparabledb_Update_Fields) (
		irreparabledb *Irreparabledb, err error)

	Update_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field,
		update Node_Update_Fields) (
		node *Node, err error)

	Update_Offer_By_Id(ctx context.Context,
		offer_id Offer_Id_Field,
		update Offer_Update_Fields) (
		offer *Offer, err error)

	Update_PendingAudits_By_NodeId(ctx context.Context,
		pending_audits_node_id PendingAudits_NodeId_Field,
		update PendingAudits_Update_Fields) (
		pending_audits *PendingAudits, err error)

	Update_ProjectPayment_By_Id(ctx context.Context,
		project_payment_id ProjectPayment_Id_Field,
		update ProjectPayment_Update_Fields) (
		project_payment *ProjectPayment, err error)

	Update_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field,
		update Project_Update_Fields) (
		project *Project, err error)

	Update_RegistrationToken_By_Secret(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field,
		update RegistrationToken_Update_Fields) (
		registration_token *RegistrationToken, err error)

	Update_User_By_Id(ctx context.Context,
		user_id User_Id_Field,
		update User_Update_Fields) (
		user *User, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

func openpostgres(source string) (*sql.DB, error) {
	return sql.Open("postgres", source)
}

var sqlite3DriverName = func() string {
	var id [16]byte
	rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}
